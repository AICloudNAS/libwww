<HTML>
<HEAD>
<TITLE>FTP access module for libwww</TITLE>
<NEXTID N="z1">
</HEAD>
<BODY>
<H1>FTP access functions</H1>
Authors

<UL>
<LI>Tim Berners-lee <timbl@info.cern.ch>
<LI>Denis DeLaRoca 310 825-4580 <CSP1DWD@mvs.oac.ucla.edu>
<LI>Lou Montulli <montulli@ukanaix.cc.ukans.edu>
<LI>Foteos Macrides <macrides@sci.wfeb.edu>
<LI>Henrik Frystyk <frystyk@dxcern.cern.ch>
</UL>

<PRE>#ifndef HTFTP_H
#define HTFTP_H
#include "HTChunk.h"
</PRE>

<H2>Retrieve File from Server</H2>

This is the FTP load module. It works as the other load modules as an
indenpendent module. It does a login and 

<PRE>
extern int  HTFTPLoad PARAMS((HTRequest * request));
</PRE>

The next two functions are for enabling and disabling reuse og control
connections on client side. Though, this is a temporary solution as the
library is going to be multi-threaded and then the control of open
connections changes. Reuse of control connections is mainly intended for use
when loading several files from the same server in the same directory, but
changing directory IS supported using FTP-commands CDUP and CWD.

<PRE>
extern void HTFTP_enable_session NOPARAMS;
extern BOOL HTFTP_disable_session NOPARAMS;
</PRE>

<PRE>
typedef enum _HTFTPServerType {
    UNKNOWN = -1,
    GENERIC_SERVER = 0,
    MACHTEN_SERVER,
    UNIX_SERVER,
    VMS_SERVER,
    CMS_SERVER,
    DCTS_SERVER,
    TCPC_SERVER,
    PETER_LEWIS_SERVER,
    NCSA_SERVER
} HTFTPServerType;

typedef enum _HTFTPMainState {
    ERROR = -2,
    FAILURE = -1,
    IDLE = 0,
    BEGIN,
    LOGGED_IN,
    GOT_DATA_CON,
    GOT_SERVER_INFO,
    GOT_DATA
} HTFTPState;

typedef struct _user_info {
    char *		     	domain;
    char *			id;
    char *			passwd;
} user_info;

typedef struct _ftp_ctrl_info {
    u_long			serv_node;           /* IP address of server */
    u_short			serv_port;	    /* Port number on server */
    int				socket;	  /* Socket number for communication */
    HTInputSocket *             isoc;			     /* Input buffer */
    char *			location;        /* Current escaped position */
    user_info *			user;           /* Userid, passwd and domain */
    HTChunk *			welcome;	      /* The welcome message */
    HTChunk *			reply;	           /* Last reply from server */
    HTFTPServerType		server;		           /* Type of server */
    BOOL			unsure_type;         /* Sure about the type? */
    BOOL			use_list;	  	  /* Can we use LIST */
    HTFTPState     		state;		  /* State of the connection */
    HTList *			data_cons;           /* The data connections */
} ftp_ctrl_info;

/* We assume that the data connection is established between the same hosts
   as the control connection */
typedef struct _ftp_data_info {
    int				socket;	  /* Socket number for communication */
    HTFormat			fileformat;   /* File format of current file */
    BOOL			active;		  /* Have we opened actively */
    BOOL 			directory;	         /* Yes if directory */
    char *			datatype;  /* See rfc959 p.48, but NO SPACE! */
    unsigned long		b_trans;      /* Number of bytes transferred */
    ftp_ctrl_info *		ctrl;		   /* Controlling connection */
} ftp_data_info;
</PRE>

<H2>Flags for FTP connections</H2>

Those are the flags for configuring the FTP client. In addition the following
defines are available in the module:

<DL>
<DT>LISTEN 
<DD>This defines makes it possible to use PORT and hence do an passive
open for the data connection. Though, if defined, this is only used AFTER
an active open has been tried using PASV.
<DT>REPEAT_PORT
<DD>If LISTEN is defined, then when we have found a passive port, then reuse
it for the next time, else we ask the system to get a new one.
<DT>POLL_PORTS
<DD>If the system doesn't support finding a new port, then let's try it
ourselves.
</DL>

<PRE>
#define WWW_FTP_CLIENT "WWWuser"
extern BOOL HTFTPUserInfo;
</PRE>

If HTFTPUserInfo = YES (as pr default) then the users login name and password
is reused when conneting to the same host. It is, however, overwritten by any
userid and passwd speficied in the URL. This is only for the client side, as
server forks itself on any request. If this flag is not set, then anonymous
and username of the current proces is used.

<PRE>
#endif
</PRE>
end
</BODY>
</HTML>


