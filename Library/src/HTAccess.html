<HEADER>
<TITLE>HTAccess:  Access manager  for libwww</TITLE>
<NEXTID N="1">
</HEADER>
<BODY>
<H1>Access Manager</H1>This module keeps a list of valid
protocol (naming scheme) specifiers
with associated access code.  It
allows documents to be loaded given
various combinations of parameters.
New access protocols may be registered
at any time.<P>
Part of the <A
NAME=z0 HREF="Overview.html">libwww library</A> .
<PRE>#ifndef HTACCESS_H
#define HTACCESS_H

/*	Definition uses:
*/
#include "HTUtils.h"
#include "tcp.h"
#include "HTAnchor.h"
#include "HTFormat.h"

#ifdef SHORT_NAMES
#define HTClientHost 		HTClHost
#define HTSearchAbsolute	HTSeAbso
#define HTOutputStream		HTOuStre
#define HTOutputFormat		HTOuForm
#endif

/*	Return codes from load routines:
**
**	These codes may be returned by the protocol modules,
**	and by the HTLoad routines.
**	In general, positive codes are OK and negative ones are bad.
*/

#define HT_NO_DATA -9999	/* return code: OK but no data was loaded */
				/* Typically, other app started or forked */

</PRE>
<H2>Default Addresses</H2>These control the home page selection.
To mess with these for normal browses
is asking for user confusion.
<PRE>#define LOGICAL_DEFAULT "WWW_HOME"  /* Defined to be the home page */

#ifndef PERSONAL_DEFAULT
#define PERSONAL_DEFAULT "WWW/default.html"	/* in home directory */
#endif
#ifndef LOCAL_DEFAULT_FILE
#define LOCAL_DEFAULT_FILE "/usr/local/lib/WWW/default.html"
#endif
/*  If one telnets to a www access point,
    it will look in this file for home page */
#ifndef REMOTE_POINTER
#define REMOTE_POINTER  "/etc/www-remote.url"  /* can't be file */
#endif
/* and if that fails it will use this. */
#ifndef REMOTE_ADDRESS
#define REMOTE_ADDRESS  "http://info.cern.ch/remote.html"  /* can't be file */
#endif

/* If run from telnet daemon and no -l specified, use this file:
*/
#ifndef DEFAULT_LOGFILE
#define DEFAULT_LOGFILE	"/usr/adm/www-log/www-log"
#endif

/*	If the home page isn't found, use this file:
*/
#ifndef LAST_RESORT
#define LAST_RESORT	"http://info.cern.ch/default.html"
#endif


</PRE>
<H2>Flags which may be set to control
this module</H2>
<PRE>extern int HTDiag;			/* Flag: load source as plain text */
extern char * HTClientHost;		/* Name or number of telnetting host */
extern FILE * logfile;			/* File to output one-liners to */
extern BOOL HTSecure;			/* Disable security holes? */
extern HTStream* HTOutputStream;	/* For non-interactive, set this */ 
extern HTFormat HTOutputFormat;		/* To convert on load, set this */



</PRE>
<H2>Load a document from relative name</H2>
<H3>On Entry,</H3>
<DL>
<DT>relative_name
<DD> The relative address
of the file to be accessed.
<DT>here
<DD> The anchor of the object being
searched
</DL>

<H3>On Exit,</H3>
<DL>
<DT>returns    YES
<DD> Success in opening
file
<DT>NO
<DD> Failure 
</DL>

<PRE>extern  BOOL HTLoadRelative PARAMS((
		CONST char * 		relative_name,
		HTParentAnchor *	here));


</PRE>
<H2>Load a document from absolute name</H2>
<H3>On Entry,</H3>
<DL>
<DT>addr
<DD> The absolute address of the
document to be accessed.
<DT>filter
<DD> if YES, treat document as
HTML
</DL>

<PRE>
</PRE>
<H3>On Exit,</H3>
<PRE>
</PRE>
<DL>
<DT>returns YES
<DD> Success in opening document
<DT>NO
<DD> Failure 
</DL>

<PRE>extern BOOL HTLoadAbsolute PARAMS((CONST char * addr));


</PRE>
<H2>Load a document from absolute name
to a stream</H2>
<H3>On Entry,</H3>
<DL>
<DT>addr
<DD> The absolute address of the
document to be accessed.
<DT>filter
<DD> if YES, treat document as
HTML
</DL>

<H3>On Exit,</H3>
<DL>
<DT>returns YES
<DD> Success in opening document
<DT>NO
<DD> Failure 
</DL>
Note: This is equivalent to HTLoadDocument
<PRE>extern BOOL HTLoadToStream PARAMS((CONST char * addr, BOOL filter,
				HTStream * sink));


</PRE>
<H2>Load if necessary, and select an
anchor</H2>
<H3>On Entry,</H3>
<DL>
<DT>destination      
<DD>    The child or
parenet anchor to be loaded.
</DL>

<PRE>
</PRE>
<H3>On Exit,</H3>
<PRE>
</PRE>
<DL>
<DT>returns YES
<DD> Success
<DT>returns NO
<DD> Failure 
</DL>

<PRE>


extern BOOL HTLoadAnchor PARAMS((HTAnchor * destination));


</PRE>
<H2>Make a stream for Saving object back</H2>
<H3>On Entry,</H3>
<DL>
<DT>anchor
<DD> is valid anchor which has
previously beeing loaded
</DL>

<H3>On exit,</H3>
<DL>
<DT>returns
<DD> 0 if error else a stream
to save the object to.
</DL>

<PRE>

extern HTStream * HTSaveStream PARAMS((HTParentAnchor * anchor));


</PRE>
<H2>Search</H2>Performs a search on word given by
the user. Adds the search words to
the end of the current address and
attempts to open the new address.
<H3>On Entry,</H3>
<DL>
<DT>*keywords
<DD> space-separated keyword
list or similar search list
<DT>here
<DD> The anchor of the object being
searched
</DL>

<PRE>extern BOOL HTSearch PARAMS((CONST char * keywords, HTParentAnchor* here));


</PRE>
<H2>Search Given Indexname</H2>Performs a keyword search on word
given by the user. Adds the keyword
to  the end of the current address
and attempts to open the new address.
<H3>On Entry,</H3>
<DL>
<DT>*keywords
<DD> space-separated keyword
list or similar search list
<DT>*indexname
<DD> is name of object search
is to be done on.
</DL>

<PRE>extern BOOL HTSearchAbsolute PARAMS((
	CONST char * 	keywords,
	CONST char * 	indexname));


</PRE>
<H2>Register an access method</H2>
<PRE>
typedef struct _HTProtocol {
	char * name;
	
	int (*load)PARAMS((
		CONST char * 	full_address,
		HTParentAnchor * anchor,
		HTFormat	format_out,
		HTStream*	sink));
		
	HTStream* (*saveStream)PARAMS((HTParentAnchor * anchor));

} HTProtocol;

extern BOOL HTRegisterProtocol PARAMS((HTProtocol * protocol));


</PRE>
<H2>Generate the anchor for the home
page</H2>
<PRE>
</PRE>As it involves file access, this
should only be done once when the
program first runs. This is a default
algorithm -- browser don't HAVE to
use this.
<PRE>extern HTParentAnchor * HTHomeAnchor NOPARAMS;

#endif /* HTACCESS_H */
</PRE>end of HTAccess</A></BODY>
