<HTML>
<HEAD>
<TITLE>Access manager  for libwww</TITLE>
<!-- Changed by: Henrik Frystyk Nielsen, 31-Jan-1996 -->
<NEXTID N="z11">
</HEAD>
<BODY>

<H1>Access Manager</H1>

<PRE>
/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/
</PRE>

This module is the application interface module to the <A
HREF="HTReq.html">Request Manager</A>. You can use the Request Manager
directly but this module makes it easier to use by providing a lot of
small request functions using the Request Manager in different
ways. It contains help functions for accessing documents and for
uploading documents to a remote server.<P>

This module is implemented by <A HREF="HTAccess.c">HTAccess.c</A>, and
it is a part of the <A HREF="http://www.w3.org/pub/WWW/Library/"> W3C
Reference Library</A>. <P>

<PRE>
#ifndef HTACCESS_H
#define HTACCESS_H

#include "HTReq.h"
#include "HTAnchor.h"
</PRE>

<A NAME="Library"><H2>Generic Library Functions</H2></A>

These are functions that affect the overall behavior of the Library.

<H3><IMG SRC="../../Icons/32x32/warning.gif"> Initializing and
Terminating the Library</H3>

These two functions initiates memory and settings for the Library and
cleans up memory kept by the Library when about to exit the
application. They <B>must</B> be used!

<PRE>
extern BOOL HTLibInit (CONST char * AppName, CONST char * AppVersion);
extern BOOL HTLibTerminate (void);
</PRE>

<H3>Library Name and Version</H3>

You can get the generic name of the Library and the version by using
the following functions:

<PRE>
extern CONST char * HTLib_name (void);
extern CONST char * HTLib_version (void);
</PRE>

<H3>Application Name and Version</H3>

Returns the name of the application and the version number that was
passed to the <CODE>HTLibInit()</CODE> function.

<PRE>
extern CONST char * HTLib_appName (void);
extern CONST char * HTLib_appVersion (void);
</PRE>

<H3>Accessing the Local File System</H3>

The Library does normally use the local file system for dumping
unknown data objects, file cache etc. In some situations this is not
desired and we can therefore turn it off. This mode also prevents you
from being able to access other resources where you have to log in, fr
example telnet.

<PRE>
extern BOOL HTLib_secure (void);
extern void HTLib_setSecure (BOOL mode);
</PRE>

<A NAME="LoadDoc"><H2>LOAD Request Methods</H2></A>

<H3>Request a document from absolute name</H3>

Request a document referencd by an absolute URL.  Returns YES if
request accepted, else NO

<PRE>
extern BOOL HTLoadAbsolute (CONST char * url, HTRequest* request);
</PRE>

<H3>Request a document from absolute name to stream</H3>

Request a document referencd by an absolute URL and sending the data
down a stream. This is _excactly_ the same as HTLoadAbsolute as the
ourputstream is specified using the function.
HTRequest_setOutputStream(). 'filter' is ignored!  Returns YES if
request accepted, else NO

<PRE>
extern BOOL HTLoadToStream (CONST char * url, BOOL filter, HTRequest *request);
</PRE>

<H3>Request a document from relative name</H3>

Request a document referenced by a relative URL. The relative URL is
made absolute by resolving it relative to the address of the 'base'
anchor. Returns YES if request accepted, else NO

<PRE>
extern BOOL HTLoadRelative (CONST char * 	relative,
			    HTParentAnchor *	base,
			    HTRequest *		request);
</PRE>

<H3>Request an anchor</H3>

Request the document referenced by the anchor Returns YES if request
accepted, else NO

<PRE>
extern BOOL HTLoadAnchor (HTAnchor * anchor, HTRequest * request);
</PRE>

<H3>Request an anchor</H3>

Same as HTLoadAnchor but any information in the Error Stack in the
request object is kept, so that any error messages in one This
function is almost identical to HTLoadAnchor, but it doesn't clear the
error stack so that the information in there is kept.  Returns YES if
request accepted, else NO

<PRE>
extern BOOL HTLoadAnchorRecursive (HTAnchor * anchor, HTRequest * request);
</PRE>

<H3>Search an Anchor</H3>

Performs a keyword search on word given by the user. Adds the keyword
to the end of the current address and attempts to open the new
address.  The list of keywords must be a space-separated list and
spaces will be converted to '+' before the request is issued.  Search
can also be performed by HTLoadAbsolute() etc.  Returns YES if request
accepted, else NO

<PRE>
extern BOOL HTSearch (CONST char *	keywords,
		      HTParentAnchor *  base,
		      HTRequest * 	request);
</PRE>

<H3>Search a document from absolute name</H3>

Request a document referencd by an absolute URL appended with the
keywords given. The URL can NOT contain any fragment identifier!  The
list of keywords must be a space-separated list and spaces will be
converted to '+' before the request is issued.  Returns YES if request
accepted, else NO

<PRE>
extern BOOL HTSearchAbsolute (CONST char *	keywords,
			      CONST char *	url,
			      HTRequest *	request);
</PRE>

<A NAME="PostDoc"><H2>POST Request Methods</H2></A>

<H3>Copy an anchor</H3>

Fetch the URL (possibly local file URL) and send it using either PUT
or POST to the remote destination using HTTP. The caller can decide the
exact method used and which HTTP header fields to transmit by setting
the user fields in the request structure.
Returns YES if request accepted, else NO

<PRE>
extern BOOL HTCopyAnchor (HTAnchor * src_anchor, HTRequest * main_req);
</PRE>

<H3>Upload an Anchor</H3>

Send the contents (in hyperdoc) of the source anchor using either PUT
or POST to the remote destination using HTTP. The caller can decide
the exact method used and which HTTP header fields to transmit by
setting the user fields in the request structure.  Returns YES if
request accepted, else NO

<PRE>
extern BOOL HTUploadAnchor (HTAnchor *		src_anchor,
			    HTParentAnchor *	dest_anchor,
			    HTRequest *		dest_req);
</PRE>

<PRE>
#endif /* HTACCESS_H */
</PRE>

End of Declaration
</BODY>
</HTML>
