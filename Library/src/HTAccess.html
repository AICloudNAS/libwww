<HTML>
<HEAD>
  <!-- Changed by: Henrik Frystyk Nielsen, 28-Jun-1996 -->
  <TITLE>W3C Reference Library libwww Accessing URLs</TITLE>
</HEAD>
<BODY>
<H1>
  Accessing URLs
</H1>
<PRE>
/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/
</PRE>
<P>
This module is the application interface module to the
<A HREF="HTReq.html">Request class</A>. It contains a lot of methods for
loading URLs and also for uploading URLs using <CODE>PUT</CODE> or
<CODE>POST</CODE>, for example. You can use the Request class directly but
this module makes it easier to use by providing a lot of small request functions
using the Request class in different ways. It contains help functions for
accessing documents and for uploading documents to a remote server.
<P>
This module is implemented by <A HREF="HTAccess.c">HTAccess.c</A>, and it
is a part of the <A HREF="http://www.w3.org/pub/WWW/Library/"> W3C Reference
Library</A>.
<PRE>
#ifndef HTACCESS_H
#define HTACCESS_H

#include "HTReq.h"
#include "HTAnchor.h"
</PRE>
<H2>
  Loading a URL
</H2>
<P>
URLs can be accesses using a character string, for example
"<CODE>http://www.w3.org</CODE>" or it can be accessed by using the libwww
representation of a URL which is called an <A HREF="HTAnchor.html">Anchor
object</A>. Note that we call all objects accessible through URLs for
<I>documents</I> - this is a notion we have inherited from the hypertext
world.
<H3>
  Request a Document from Absolute URL
</H3>
<P>
Request a document referencd by an <I>absolute</I> URL. The output from the
request is passed to the <A HREF="HTFormat.html">Stream Pipe Manager</A>
that figures out where to pump the data. This can for example be to the display
or to a local file depending on the set of
<A HREF="HTFormat.html#type">converters</A> registered by the application.
<PRE>extern BOOL HTLoadAbsolute (const char * url, HTRequest * request);
</PRE>
<H3>
  Request a Document from Relative URL
</H3>
<P>
Request a document referenced by a <I>relative</I> URL. The relative URL
is made absolute by resolving it relative to the address of the '<I>base</I>'
anchor.
<PRE>extern BOOL HTLoadRelative (const char * 	relative,
			    HTParentAnchor *	base,
			    HTRequest *		request);
</PRE>
<H3>
  Load a URL into Memory
</H3>
<P>
Request a document referred to by the URL and load it into a chunk object.
A <A HREF="HTChunk.html">chunk object</A> is a dynamic string so in the end
you will have a single memory buffer containing the document.
<PRE>extern HTChunk * HTLoadToChunk (const char * url, HTRequest * request);
</PRE>
<H3>
  Request a Document using an Anchor
</H3>
<P>
Here the URL is represented by an <A HREF="HTAnchor.html">Anchor object</A>.
You can get an anchor object representing a URL by passing the URL to the
approproiate method in the <A HREF="HTAnchor.html">Anchor class</A>.
<PRE>extern BOOL HTLoadAnchor (HTAnchor * anchor, HTRequest * request);
</PRE>
<H3>
  Load a URL into Memory using an Anchor
</H3>
<P>
This is the same as HTLoadToChunk but instead of passing a URL string you
pass an anchor object. Internally, all URLs are represented as anchors which
contains all the information we have about the resource.
<PRE>extern HTChunk * HTLoadAnchorToChunk (HTAnchor * anchor, HTRequest * request);
</PRE>
<H3>
  Recursively Request a Document using an Anchor
</H3>
<P>
Same as <CODE>HTLoadAnchor()</CODE> but the information in the error stack
in the request object is kept, so that any error messages in one. This function
is almost identical to <CODE>HTLoadAnchor</CODE>, but it doesn't clear the
error stack so that the information in there is kept. Returns YES if request
accepted, else NO
<PRE>extern BOOL HTLoadAnchorRecursive (HTAnchor * anchor, HTRequest * request);
</PRE>
<H2>
  Searching a URL
</H2>
<H3>
  Search an Anchor
</H3>
<P>
Performs a keyword search on word given by the user. Adds the keyword to
the end of the current address and attempts to open the new address. The
list of keywords must be a space-separated list and spaces will be converted
to '+' before the request is issued. Search can also be performed by
HTLoadAbsolute() etc. Returns YES if request accepted, else NO
<PRE>
extern BOOL HTSearch (const char *	keywords,
		      HTParentAnchor *  base,
		      HTRequest * 	request);
</PRE>
<H3>
  Search a document from absolute name
</H3>
<P>
Request a document referencd by an absolute URL appended with the keywords
given. The URL can NOT contain any fragment identifier! The list of keywords
must be a space-separated list and spaces will be converted to '+' before
the request is issued. Returns YES if request accepted, else NO
<PRE>extern BOOL HTSearchAbsolute (const char *	keywords,
			      const char *	url,
			      HTRequest *	request);
</PRE>
<H2>
  Saving a URL
</H2>
<H3>
  Copy an anchor
</H3>
<P>
Fetch the URL from either local file store <B>or</B> from a remote HTTP server
and send it using either PUT or POST to the remote destination using HTTP.
The caller can decide the exact method used and which HTTP header fields
to transmit by setting the user fields in the request structure. If posting
to NNTP then we can't dispatch at this level but must pass the source anchor
to the news module that then takes all the refs to NNTP and puts into the
"newsgroups" header Returns YES if request accepted, else NO
<PRE>extern BOOL HTCopyAnchor (HTAnchor * src_anchor, HTRequest * main_req);
</PRE>
<H3>
  Upload an Anchor
</H3>
<P>
This function can be used to send data along with a request to a remote server.
It can for example be used to POST form data to a remote HTTP server - or
it can be used to post a newsletter to a NNTP server. In either case, you
pass a callback function which the request calls when the remote destination
is ready to accept data. In this callback you get the current request object
and a stream into where you can write data. It is very important that you
return the value returned by this stream to the Library so that it knows
what to do next. The reason is that the outgoing stream might block or an
error may occur and in that case the Library must know about it. If you do
not want to handle the stream interface yourself then you can use the
<CODE>HTUpload_callback</CODE> which is declared below.
<P>
The source anchor represents the data object in memory and it points to the
destination anchor by using the
<A HREF="../User/Architecture/PostWeb.html">POSTWeb method</A>. The source
anchor contains metainformation about the data object in memory and the
destination anchor represents the reponse from the remote server. Returns
YES if request accepted, else NO
<PRE>extern BOOL HTUploadAnchor (HTAnchor *		source_anchor,
			    HTRequest * 	request,
			    HTPostCallback *	callback);
</PRE>
<H3>
  POST Callback Handler
</H3>
<P>
Is you do not want to handle the stream interface on your own, you can use
this "middleman" function which does the actual writing to the target stream
for the anchor upload and also handles the return value from the stream.
Now, your application is called via the callback function that you may associate
with a request object. You indicate when you have sent all the data you want
by returning HT_LOADED from the callback.
<PRE>
extern int HTUpload_callback (HTRequest * request, HTStream * target);
</PRE>
<PRE>
#endif /* HTACCESS_H */
</PRE>
<P>
  <HR>
<ADDRESS>
  @(#) $Id$
</ADDRESS>
</BODY></HTML>
