<HTML>
<HEAD>
<TITLE>HTAccess:  Access manager  for libwww</TITLE>
<NEXTID N="z6">
</HEAD>
<BODY>
<H1>Access Manager</H1>This module keeps a list of valid
protocol (naming scheme) specifiers
with associated access code.  It
allows documents to be loaded given
various combinations of parameters.
New access protocols may be registered
at any time.<P>
Note: HTRequest defined and request
parametsr added to almost all calls
18 Nov 1993.<P>
Part of the <A
NAME="z0" HREF="Overview.html">libwww library</A> .
<PRE>#ifndef HTACCESS_H
#define HTACCESS_H

/*	Definition uses:
*/
#include "HTUtils.h"
#include "tcp.h"

#ifdef SHORT_NAMES
#define HTClientHost 		HTClHost
#define HTSearchAbsolute	HTSeAbso
#define HTOutputStream		HTOuStre
#define HTOutputFormat		HTOuForm
#endif

</PRE>The following have to be defined
in advance of the other include files
because of circular references.
<PRE>typedef struct _HTRequest HTRequest;

#include "HTAnchor.h"
#include <A
NAME="z3" HREF="HTFormat.html">"HTFormat.h"</A>


/*	Return codes from load routines:
**
**	These codes may be returned by the protocol modules,
**	and by the HTLoad routines.
**	In general, positive codes are OK and negative ones are bad.
*/

#define HT_NO_DATA -9999	/* return code: OK but no data was loaded */
				/* Typically, other app started or forked */

</PRE>
<H2>Default Addresses</H2>These control the home page selection.
To mess with these for normal browses
is asking for user confusion.
<PRE>#define LOGICAL_DEFAULT "WWW_HOME"  /* Defined to be the home page */

#ifndef PERSONAL_DEFAULT
#define PERSONAL_DEFAULT "WWW/default.html"	/* in home directory */
#endif
#ifndef LOCAL_DEFAULT_FILE
#define LOCAL_DEFAULT_FILE "/usr/local/lib/WWW/default.html"
#endif
/*  If one telnets to a www access point,
    it will look in this file for home page */
#ifndef REMOTE_POINTER
#define REMOTE_POINTER  "/etc/www-remote.url"  /* can't be file */
#endif
/* and if that fails it will use this. */
#ifndef REMOTE_ADDRESS
#define REMOTE_ADDRESS  "http://info.cern.ch/remote.html"  /* can't be file */
#endif

/* If run from telnet daemon and no -l specified, use this file:
*/
#ifndef DEFAULT_LOGFILE
#define DEFAULT_LOGFILE	"/usr/adm/www-log/www-log"
#endif

/*	If the home page isn't found, use this file:
*/
#ifndef LAST_RESORT
#define LAST_RESORT	"http://info.cern.ch/default.html"
#endif


</PRE>
<H2><A
NAME="z1">The Request structure</A></H2>When a request is handled, all kinds
of things about it need to be passed
along.  These are all put into a
HTRequest structure.  Note there
is also a <A
NAME="z4" HREF="HTFormat.html#z17">global list of converters</A>.
<PRE>struct _HTRequest {
	HTList * 	<A
NAME="z5">conversions</A>;	/* conversions allowed in this case */
	char *		from;		/* On behalf of whom? */
	HTStream*	output_stream;	/* For non-interactive, set this */ 
	HTAtom * 	output_format;	/* To convert on load, set this */
	BOOL		(*callback) PARAMS((
				struct _HTRequest* request,
				void *param));
	void *		context;	/* caller data -- HTAccess unaware */

	HTParentAnchor*	anchor;		/* Set by HTAccess */
	/* To be added: authentication, etc */
};

</PRE>The elements of the request structure
are as follows.
<DL>
<DT>conversions
<DD> NULL, or a list of conversions
which the format manager can do in
order to fulfill the request.  This
is set by the caller of HTAccess.
Typically points to a list set up
an initialisation time for example
by HTInit.
<DT>from
<DD> Email format adderss of person
responible for request
<DT>output_stream
<DD> NULL or if a specific
output stream is required, te stream.
<DT>output_format
<DD> The output format required,
or a generic format such as www/present
(present to user). 
<DT>anchor
<DD> The anchor for teh object
in question.  NOTE: Set by HTAcesss.
</DL>
Just to make things easier especially
for clients, here is a function to
return a new blank request:
<H2>Create blank request</H2>This request has defaults in -- in
most cases it will need some information
added before being passed to HTAccess,
but it will work as is for a simple
request.
<PRE>extern HTRequest * HTRequest_new NOPARAMS;


</PRE>
<H2>Flags which may be set to control
this module</H2>
<PRE>extern int HTDiag;			/* Flag: load source as plain text */
extern char * HTClientHost;		/* Name or number of telnetting host */
extern FILE * logfile;			/* File to output one-liners to */
extern BOOL HTSecure;			/* Disable security holes? */



</PRE>
<H2>Load a document from relative name</H2>
<H3>On Entry,</H3>
<DL>
<DT>relative_name
<DD> The relative address
of the file to be accessed.
<DT>here
<DD> The anchor of the object being
searched
<DT>request->anchor
<DD> not filled in yet
</DL>

<H3>On Exit,</H3>
<DL>
<DT>returns    YES
<DD> Success in opening
file
<DT>NO
<DD> Failure 
</DL>

<PRE>extern  BOOL HTLoadRelative PARAMS((
		CONST char * 		relative_name,
		HTParentAnchor *	here,
		HTRequest *		request));


</PRE>
<H2>Load a document from absolute name</H2>
<H3>On Entry,</H3>
<DL>
<DT>addr
<DD> The absolute address of the
document to be accessed.
<DT>filter
<DD> if YES, treat document as
HTML
<DT>request->anchor
<DD> not filled in yet
</DL>

<PRE>
</PRE>
<H3>On Exit,</H3>
<PRE>
</PRE>
<DL>
<DT>returns YES
<DD> Success in opening document
<DT>NO
<DD> Failure 
</DL>

<PRE>extern BOOL HTLoadAbsolute PARAMS((CONST char * addr,
		HTRequest *		request));


</PRE>
<H2>Load a document from absolute name
to a stream</H2>
<H3>On Entry,</H3>
<DL>
<DT>addr
<DD> The absolute address of the
document to be accessed.
<DT>filter
<DD> if YES, treat document as
HTML
<DT>request->anchor
<DD> not filled in yet
</DL>

<H3>On Exit,</H3>
<DL>
<DT>returns YES
<DD> Success in opening document
<DT>NO
<DD> Failure 
</DL>
Note: This is equivalent to HTLoadDocument
<PRE>extern BOOL HTLoadToStream PARAMS((
		CONST char * 		addr,
		BOOL 			filter,
		HTRequest *		request));


</PRE>
<H2>Load if necessary, and select an
anchor</H2>The anchor parameter may be a child
anchor. The anchor in the request
is set to the parent anchor.
<H3>On Entry,</H3>
<DL>
<DT>anchor
<DD> may be a child or parenet
anchor or 0 in which case there is
no effect.
<DT>request->anchor      
<DD>    Not set
yet.
</DL>

<H3>On Exit,</H3>
<PRE>
</PRE>
<DL>
<DT>returns YES
<DD> Success
<DT>returns NO
<DD> Failure 
<DT>request->anchor
<DD> The parenet anchor.
</DL>

<PRE>extern BOOL HTLoadAnchor PARAMS((HTAnchor * a,
			HTRequest *		request));


</PRE>
<H2>Make a stream for Saving object back</H2>
<H3>On Entry,</H3>
<DL>
<DT>request->anchor
<DD> is valid anchor which
has previously beeing loaded
</DL>

<H3>On exit,</H3>
<DL>
<DT>returns
<DD> 0 if error else a stream
to save the object to.
</DL>

<PRE>

extern HTStream * HTSaveStream PARAMS((HTParentAnchor* anchor,
			HTRequest *		request));


</PRE>
<H2>Search</H2>Performs a search on word given by
the user. Adds the search words to
the end of the current address and
attempts to open the new address.
<H3>On Entry,</H3>
<DL>
<DT>*keywords
<DD> space-separated keyword
list or similar search list
<DT>here
<DD> The anchor of the object being
searched
</DL>

<PRE>extern BOOL HTSearch PARAMS((
		CONST char *		keywords,
		HTParentAnchor*		here,
		HTRequest *		request));


</PRE>
<H2>Search Given Indexname</H2>Performs a keyword search on word
given by the user. Adds the keyword
to  the end of the current address
and attempts to open the new address.
<H3>On Entry,</H3>
<DL>
<DT>*keywords
<DD> space-separated keyword
list or similar search list
<DT>*indexname
<DD> is name of object search
is to be done on.
</DL>

<PRE>extern BOOL HTSearchAbsolute PARAMS((
	CONST char * 		keywords,
	CONST char * 		indexname,
	HTRequest *		request));


</PRE>
<H2>Register an access method</H2>An access method is defined by an
HTProtocol structure which point
to the routines for performing the
various logical operations on an
object: in HTTP terms,  GET, PUT,
and POST.<P>
Each of these routine takes as a
parameter a <A
NAME="z2" HREF="#z1">request structure</A> containing
details ofthe request.  When the
protocol class routine is called,
the anchor elemnt in the request
is already valid (made valid by HTAccess).
<PRE>typedef struct _HTProtocol {
	char * name;
	
	int (*load)PARAMS((HTRequest *	request));
		
	HTStream* (*saveStream)PARAMS((HTRequest *	request));

	HTStream* (*postStream)PARAMS((
				HTRequest *	request,
				HTParentAnchor* postTo));

} HTProtocol;

extern BOOL HTRegisterProtocol PARAMS((HTProtocol * protocol));


</PRE>
<H2>Generate the anchor for the home
page</H2>
<PRE>
</PRE>As it involves file access, this
should only be done once when the
program first runs. This is a default
algorithm -- browser don't HAVE to
use this.
<PRE>extern HTParentAnchor * HTHomeAnchor NOPARAMS;

#endif /* HTACCESS_H */

</PRE>end of HTAccess</A></BODY>
</HTML>
