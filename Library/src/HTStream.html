<HTML>
<HEAD>
<TITLE>The Generic Stream Class Definition</TITLE></HEAD>
<BODY>
<H1>Stream Object definition</H1>

A Stream object is something which accepts a stream of text. This
module is a part on the <A HREF="Overview.html">Library of Common
Code</A>. See also the <A HREF="SGML.html">Structured stream
definition.</A><P>

The creation methods will vary on
the type of Stream Object.   All
creation methods return a pointer
to the stream type below.<P>
As you can see, but the methods used
to write to the stream and close
it are pointed to be the object itself.
<PRE>#ifndef HTSTREAM_H
#define HTSTREAM_H

#include "HTUtils.h"

typedef struct _HTStream HTStream;

</PRE>These are the common methods of all
streams.  They should be self-explanatory,
except for end_document which must
be called before free.  It should
be merged with free in fact:  it
should be dummy for new streams.<P>

<B>NOTE: </B>The <CODE>put_block</CODE> method was <CODE>write</CODE>, but this
upset systems which had macros for <CODE>write()</CODE><P>

<B>NOTE: </B>The methods <CODE>_free</CODE> and <CODE>abort</CODE> in
the stream are now integers and not void anymore. The general return
codes from the methods are:

<UL>
<LI>Error: EOF
<LI>OK: &gt;=0
</UL>

The positive return codes can be used freely by the streams.  An
explanation on an error occured can be parsed using the <A
HREF="HTError.html">Error Module</A>.

<PRE>typedef struct _HTStreamClass {

	char*  name;				/* Just for diagnostics */
		
	int (*_free) PARAMS((
		HTStream*	me));

	int (*abort) PARAMS((
		HTStream*	me,
		HTError		e));
		
	void (*put_character) PARAMS((
		HTStream*	me,
		char		ch));
				
	void (*put_string) PARAMS((
		HTStream*	me,
		CONST char *	str));
		
	void (*put_block) PARAMS((
		HTStream*	me,
		CONST char *	str,
		int		len));
		
		
} HTStreamClass;

#endif /* HTSTREAM_H */

</PRE>end of HTStream.h</A></BODY>
</HTML>
