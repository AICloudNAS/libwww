<html>
<head>
  <meta http-equiv="Content-Type" content="text/html">
  <!-- Changed by: Henrik Frystyk Nielsen, 15-Jul-1996 -->
  <title>W3C Sample Code Library libwww Private Request Definition</title>
</head>

<body>
<h1>Private Request Definition</h1>
<pre>/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/</pre>

<p>This module is the private part of the request object. It has the
functions declarations that are private to the Library and that shouldn't be
used by applications. The module has been separated from the old HTAccess
module. See also the public part of the declarition in the <a
href="HTReq.html">HTReq Module</a>.</p>

<p>This module is implemented by <a href="HTReqMan.c">HTReqMan.c</a>, and it
is a part of the <a href="http://www.w3.org/Library/"> W3C Sample Code
Library</a>.</p>
<pre>#ifndef HTREQMAN_H
#define HTREQMAN_H

#include "<a href="HTReq.html">HTReq.h</a>"
#include "<a href="HTList.html">HTList.h</a>"
#include "<a href="HTFormat.html">HTFormat.h</a>"
#include "<a href="HTAnchor.html">HTAnchor.h</a>"
#include "<a href="HTMethod.html">HTMethod.h</a>"
#include "<a href="HTAABrow.html">HTAABrow.h</a>"
#include "<a href="HTStream.html">HTStream.h</a>"
#include "<a href="HTNet.html">HTNet.h</a>"
#include "<a href="HTMIMPrs.html">HTMIMPrs.h</a>"</pre>

<p>When a request is handled, all kinds of things about it need to be passed
along together with a request. It is intended to live as long as the request
is still active, but can be deleted as soon as it has terminated. Only the
anchor object stays around after the request itself is terminated.</p>
<pre>struct _HTRequest {

    BOOL		internal;      /* Does the app knows about this one? */

    time_t		date;      /* Time stamp when the request was issued */

    HTMethod		method;

    BOOL                flush;                /* Should we flush immediately */

    HTPriority          priority;   /* Priority for this request */</pre>

<h3>Message body</h3>

<p>A request message body indicated for XML bodies. It is used for extension
methods. See <a href="HTReq.html">HTReq.html</a> for details. </p>
<pre>#ifdef HT_EXT
    char *             messageBody;
    long int           messageBodyLength;
    HTFormat           messageBodyFormat;
#endif</pre>

<h3>User Profile</h3>

<p>Each request can be assigned a <a href="HTUser.html">user profile</a>
containing information about this host and the user issuing the request.</p>
<pre>    HTUserProfile *        userprofile;</pre>

<h3>Net Object</h3>

<p>Each request is assigned a Net object which contains pointers to other
objects handling the request.</p>
<pre>    HTNet *                net;                    /* Information about socket etc. */</pre>

<h3>Response Object</h3>

<p>When we start getting MIME headers in as a response we keep it in this
object until we know what to do with it.</p>
<pre>    HTResponse *        response;</pre>

<h3>Error Manager</h3>
<pre>    HTList *                error_stack;                           /* List of errors */</pre>

<h3>Have many times do We Want to Try?</h3>
<pre>    int                        retrys;                     /* Number of automatic reloads */
    int                 max_forwards;
    int			AAretrys;      	      /* Number of authentication
                                                 retries */</pre>

<h3>Preemptive or Non-Preemptive load?</h3>

<p>Each protocol module is registered with a default behavior but if you have
registered a protocol module for non-preemtive load you can override this by
using the following flag.</p>
<pre>    BOOL                preemptive;</pre>

<h3>Content Negotiation</h3>

<p>Normally, when we access the local file system we do content negotiation
in order to find the most suited representation. However, you can turn this
off by using the following flag.</p>
<pre>    BOOL                ContentNegotiation;</pre>

<h3>Should we use preconditions?</h3>
<pre>    HTPreconditions     preconditions;</pre>

<h3>Headers and header information</h3>

<p>These are the masks that decides what headers to send.</p>
<pre>    HTGnHd                GenMask;
    HTRsHd		ResponseMask;
    HTRqHd		RequestMask;
    HTEnHd                EntityMask;</pre>

<h3>Local MIME Header Parsers</h3>

<p>Each request can be assigned its own MIME header parsers.</p>
<pre>    HTMIMEParseSet *        parseSet;
    BOOL                pars_local;</pre>

<h3>Accept headers</h3>

<p>These are the accept headers that we want to send out.</p>
<pre>    HTList *                conversions;
    BOOL		conv_local;

    HTList *		encodings;
    BOOL		enc_local;

    HTList *		tes;
    BOOL		te_local;

    HTList *		languages;
    BOOL		lang_local;

    HTList *		charsets;
    BOOL		char_local;

    HTList *		befores;
    BOOL		befores_local;

    HTList *		afters;
    BOOL                afters_local;</pre>

<h3>Are we using a Proxy?</h3>

<p>If so then we keep the name in this variable</p>
<pre>    char *                 proxy;
    BOOL                full_uri;</pre>

<h3>Cache Control Directives</h3>

<p>This association list is a list of the cache control directives that are
to be sent as part of the <code>Cache-Control</code> header.</p>
<pre>    HTReload                reload;
    HTAssocList *       cache_control;</pre>

<h3>Default PUT name</h3>

<p>Stores the default name when publishing to a "/" URL.</p>
<pre>   char *               default_put_name;</pre>

<h3>Byte Ranges</h3>

<p>This association list is a list of the cache control directives that are
to be sent as part of the <code>Range</code> header.</p>
<pre>    HTAssocList *       byte_ranges;</pre>

<h3>Connection Control Directives</h3>

<p>This association list is a list of the connection control directives that
are to be sent as part of the <code>Connection</code> header.</p>
<pre>    HTAssocList *       connection;</pre>

<h3>Expect Directives</h3>

<p>The Expect request-header field is used to indicate that particular server
behaviors are required by the client. A server that does not understand or is
unable to comply with any of the expectation values in the Expect field of a
request MUST respond with appropriate error status.</p>
<pre>    HTAssocList *       expect;</pre>

<h3>Access Authentication Information</h3>

<p>The <code>credentials</code> list contains the information that we are to
send as part of the <code>Authorization</code> header. The realm is if we
already know that we need to generate credentials for a specific realm.</p>
<pre>    char *                realm;                                    /* Current realm */
    HTAssocList *        credentials;           /* Credentials received by server */</pre>

<h3>Request Header Extensibility</h3>

<p></p>
<hr>

<h4>1) Simple Association List</h4>

<p>Add the (name, value) and it will be converted into MIME header format as
<code>name: value</code>. DO NOT ADD CRLF line termination - this is done by
the <a href="HTTPReq.html">HTTP header generator stream</a></p>
<pre>    HTAssocList        *        extra_headers;</pre>

<h4>2) Stream Oriented Header Generators</h4>

<p>A generator is a stream with direct access to the output stream</p>
<pre>    HTList *                generators;
    BOOL                gens_local;</pre>

<h4>4) HTTP Extension Framework</h4>

<p>These association lists contain the information that we are to send as <a
href="/Protocols/HTTP/ietf-http-ext/">HTTP Extension Framework</a>.</p>
<pre>    HTAssocList *        mandatory;
    HTAssocList *        optional;</pre>

<h3>Anchors</h3>
<pre>    HTParentAnchor *        anchor;               /* The Client anchor for this request */

    HTChildAnchor *	childAnchor;	    /* For element within the object */
    HTParentAnchor *        parentAnchor;                        /* For referer field */</pre>

<h3>Streams From Network to Application</h3>
<pre>    HTStream *                output_stream; 
    HTStream *		orig_output_stream; 
    HTFormat		output_format;
    BOOL		connected;

    HTStream *		debug_stream;
    HTStream *		orig_debug_stream;
    HTFormat                debug_format;</pre>

<h3>Streams From Application to Network</h3>
<pre>    HTStream *                input_stream; 
    HTFormat                input_format;</pre>

<h3>Callback Function for getting data down the Input Stream</h3>
<pre>    HTPostCallback *        PostCallback;</pre>

<h3>Context Swapping</h3>
<pre>    HTRequestCallback *        callback;
    void *                context;</pre>

<h3>PostWeb Information (Not used anymore - don't use!)</h3>
<pre>    HTRequest *                source;                     /* Source for request or itself */
    HTParentAnchor *	source_anchor;		  /* Source anchor or itself */

    HTRequest *		mainDestination;	     /* For the typical case */
    HTList *		destinations;		 /* List of related requests */
    int			destRequests;	   /* Number of destination requests */
    int                        destStreams;            /* Number of destination streams */</pre>
<pre>};</pre>

<h2>Post Web Management</h2>

<p>These functions are mainly used internally in the Library but there is no
reason for them not to be public.</p>
<pre>extern BOOL HTRequest_addDestination (HTRequest * src, HTRequest * dest);
extern BOOL HTRequest_removeDestination	(HTRequest * dest);
extern BOOL HTRequest_destinationsReady (HTRequest * me);

extern BOOL HTRequest_linkDestination (HTRequest * dest);
extern BOOL HTRequest_unlinkDestination (HTRequest * dest);

extern BOOL HTRequest_removePostWeb (HTRequest * me);
extern BOOL HTRequest_killPostWeb (HTRequest * me);

#define	HTRequest_mainDestination(me) \
	((me) &amp;&amp; (me)-&gt;source ? (me)-&gt;source-&gt;mainDestination : NULL)
#define HTRequest_isDestination(me) \
	((me) &amp;&amp; (me)-&gt;source &amp;&amp; (me) != (me)-&gt;source)
#define HTRequest_isMainDestination(me) \
	((me) &amp;&amp; (me)-&gt;source &amp;&amp; \
	(me) == (me)-&gt;source-&gt;mainDestination)
#define HTRequest_isSource(me) \
        ((me) &amp;&amp; (me)-&gt;source &amp;&amp; (me) == (me)-&gt;source)</pre>

<p>End of Declaration</p>
<pre>#endif /* HTREQMAN_H */</pre>

<p></p>
<hr>
<address>
  @(#) $Id$
</address>
</body>
</html>
