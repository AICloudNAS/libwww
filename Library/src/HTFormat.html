<HTML>
<HEAD>
<TITLE>W3C Reference Library libwww FORMAT NEGOTIATION</TITLE>
<!-- Changed by: Henrik Frystyk Nielsen, 17-Apr-1996 -->
<NEXTID N="z18">
</HEAD>
<BODY>

<H1>The Format Manager</H1>

<PRE>
/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/
</PRE>

Here we describe the functions of the HTFormat module which handles
conversion between different data representations. (In MIME parlance,
a representation is known as a content-type. In <A
HREF="http://www.w3.org/pub/WWW/TheProject.html">WWW</A> the
term <EM>format</EM> is often used as it is shorter).The content of
this module is:

<UL>
<LI><A HREF="#CT">Content Type Converters and Presenters</A>
<LI><A HREF="#CE">Content Encoders and Decoders</A>
<LI><A HREF="#charset">Content Charsets</A>
<LI><A HREF="#language">Natural Languages</A><P>

<LI><A HREF="#global">Global Preferences</A><P>

<LI><A HREF="#CTStack">The Content Type Stream Stack</A>
<LI><A HREF="#CEStack">Content Encoding Stream Stack</A>
<LI><A HREF="#CTEStack">Content Transfer Encoding Stream Stack</A><P>

<LI><A HREF="#Rank">Content Negotiation</A>
</UL>

This module is implemented by <A HREF="HTFormat.c">HTFormat.c</A>, and
it is a part of the <A HREF="http://www.w3.org/pub/WWW/Library/"> W3C
Reference Library</A>.

<PRE>
#ifndef HTFORMAT_H
#define HTFORMAT_H

#include "<A HREF="HTUtils.html">HTUtils.h</A>"
#include "<A HREF="HTStream.html">HTStream.h</A>"
#include "<A HREF="HTAtom.html">HTAtom.h</A>"
#include "<A HREF="HTList.html">HTList.h</A>"
#include "<A HREF="HTAnchor.html">HTAnchor.h</A>"
#include "<A HREF="HTReq.html">HTReq.h</A>"
</PRE>

<A NAME="CT"><H2>Content Type Converters and Presenters</H2></A>

This is the description of how we hande content types (media types)

<H3>Content Type Converters</H3></A>

A <CODE><A NAME="z12">converter</A></CODE> is a stream with a special
set of parameters and which is registered as capable of converting
from a MIME type to something else (maybe another MIME-type). A
converter is defined to be a function returning a stream and accepting
the following parameters. The content type elements are atoms for
which we have defined a prototype.

<PRE>
typedef HTStream * HTConverter	(HTRequest *	request,
				 void *		param,
				 HTFormat	input_format,
				 HTFormat	output_format,
				 HTStream *	output_stream);
</PRE>

<H3>The HTPresentation Object</H3>

A <CODE>presenter</CODE> is a module (possibly an external program)
which can present a graphic object of a certain MIME type to the
user. That is, <CODE>presenters</CODE> are normally used to present
objects that the <CODE>converters</CODE> are not able to handle. Data
is transferred to the external program using for example the <A
HREF="HTFWrite.html">HTSaveAndExecute</A> stream which writes to a
local file. Both presenters and converters are of the type <A
HREF="#converter">HTConverter</A>.

<PRE>
typedef struct _HTPresentation {
    HTFormat	rep;			     /* representation name atomized */
    HTFormat	rep_out;			 /* resulting representation */
    HTConverter *converter;	      /* The routine to gen the stream stack */
    char *	command;			       /* MIME-format string */
    char *	test_command;			       /* MIME-format string */
    double	quality;		     /* Between 0 (bad) and 1 (good) */
    double	secs;
    double	secs_per_byte;
} HTPresentation;
</PRE>

<H3>Basic Content type Converters</H3>

We have a small set of basic converters that can be hooked in
anywhere. They don't "convert" anything but are nice to have.

<PRE>
extern HTConverter HTThroughLine;
extern HTConverter HTBlackHoleConverter;
</PRE>

<H3>Predefined Content Types</H3>

These macros (which used to be constants) define some basic internally
referenced representations. The <CODE>www/xxx</CODE> ones are of
course not MIME standard. They are internal representations used in
the Library but they can't be exported to other apps!

<PRE>
#define WWW_RAW		HTAtom_for("www/void")   /* Raw output from Protocol */
</PRE>

<CODE>WWW_RAW</CODE> is an output format which leaves the input
untouched <EM>exactly</EM> as it is received by the protocol
module. For example, in the case of FTP, this format returns raw ASCII
objects for directory listings; for HTTP, everything including the
header is returned, for Gopher, a raw ASCII object is returned for a
menu etc.

<PRE>
#define WWW_SOURCE	HTAtom_for("*/*")   /* Almost what it was originally */
</PRE>

<CODE>WWW_SOURCE</CODE> is an output format which leaves the input
untouched <EM>exactly</EM> as it is received by the protocol module
<B>IF</B> not a suitable converter has been registered with a quality
factor higher than 1 (for example 2). In this case the <EM>SUPER
CONVERTER</EM> is preferred for the raw output. This can be used as a
filter effect that allows conversion from, for example raw
FTPdirectory listings into HTML but passes a MIME body untouched.

<PRE>
#define WWW_PRESENT	HTAtom_for("www/present")   /* The user's perception */
</PRE>

<CODE>WWW_PRESENT</CODE> represents the user's perception of the
document.  If you convert to <CODE>WWW_PRESENT</CODE>, you present the
material to the user.

<PRE>
#define WWW_DEBUG	HTAtom_for("www/debug")
</PRE>

<CODE>WWW_DEBUG</CODE> represents the user's perception of debug
information, for example sent as a HTML document in a HTTP redirection
message.

<PRE>
#define WWW_UNKNOWN     HTAtom_for("www/unknown")
</PRE>

<CODE>WWW_UNKNOWN</CODE> is a really unknown type. It differs from the
real MIME type <EM>"application/octet-stream"</EM> in that we haven't
even tried to figure out the content type at this point.<P>

These are regular MIME types defined. Others can be added!

<PRE>
#define WWW_HTML 	HTAtom_for("text/html")
#define WWW_PLAINTEXT 	HTAtom_for("text/plain")

#define WWW_MIME	HTAtom_for("message/rfc822")
#define WWW_MIME_HEAD	HTAtom_for("message/x-rfc822-head")
#define WWW_MIME_FOOT	HTAtom_for("message/x-rfc822-foot")

#define WWW_AUDIO       HTAtom_for("audio/basic")

#define WWW_VIDEO 	HTAtom_for("video/mpeg")

#define WWW_GIF 	HTAtom_for("image/gif")
#define WWW_JPEG 	HTAtom_for("image/jpeg")
#define WWW_TIFF 	HTAtom_for("image/tiff")
#define WWW_PNG 	HTAtom_for("image/png")

#define WWW_BINARY 	HTAtom_for("application/octet-stream")
#define WWW_POSTSCRIPT 	HTAtom_for("application/postscript")
#define WWW_RICHTEXT 	HTAtom_for("application/rtf")
</PRE>

We also have some MIME types that come from the various protocols when
we convert from ASCII to HTML.

<PRE>
#define WWW_GOPHER_MENU HTAtom_for("text/x-gopher")
#define WWW_CSO_SEARCH	HTAtom_for("text/x-cso")

#define WWW_FTP_LNST	HTAtom_for("text/x-ftp-lnst")
#define WWW_FTP_LIST	HTAtom_for("text/x-ftp-list")

#define WWW_NNTP_LIST   HTAtom_for("text/x-nntp-list")
#define WWW_NNTP_OVER	HTAtom_for("text/x-nntp-over")
#define WWW_NNTP_HEAD	HTAtom_for("text/x-nntp-head")

#define WWW_HTTP	HTAtom_for("text/x-http")
</PRE>

Finally we have defined a special format for our RULE files as they
can be handled by a special converter.

<PRE>
#define WWW_RULES	HTAtom_for("application/x-www-rules")
</PRE>

<H3>Register Presenters</H3>

This function creates a presenter object and adds to the list of
conversions.

<DL>
<DT>conversions
<DD>The list of <CODE>conveters</CODE> and <CODE>presenters</CODE>
<DT>rep_in
<DD>the MIME-style format name
<DT>rep_out
<DD>is the resulting content-type after the conversion
<DT>converter
<DD>is the routine to call which actually does the conversion
<DT>quality
<DD>A degradation faction [0..1]
<DT>maxbytes
<DD>A limit on the length acceptable as input (0 infinite)
<DT>maxsecs
<DD>A limit on the time user will wait (0 for infinity)
</DL>

<PRE>
extern void HTPresentation_add (HTList *	conversions,
				const char * 	representation,
				const char * 	command,
				const char * 	test_command,
				double		quality,
				double		secs, 
				double		secs_per_byte);

extern void HTPresentation_deleteAll	(HTList * list);
</PRE>

<H3>Register Converters</H3>

This function creates a presenter object and adds to the list of
conversions.

<DL>
<DT>conversions
<DD>The list of <CODE>conveters</CODE> and <CODE>presenters</CODE>
<DT>rep_in
<DD>the MIME-style format name
<DT>rep_out
<DD>is the resulting content-type after the conversion
<DT>converter
<DD>is the routine to call which actually does the conversion
<DT>quality
<DD>A degradation faction [0..1]
<DT>maxbytes
<DD>A limit on the length acceptable as input (0 infinite)
<DT>maxsecs
<DD>A limit on the time user will wait (0 for infinity)
</DL>

<PRE>
extern void HTConversion_add   (HTList *	conversions,
				const char * 	rep_in,
				const char * 	rep_out,
				HTConverter *	converter,
				double		quality,
				double		secs, 
				double		secs_per_byte);

extern void HTConversion_deleteAll	(HTList * list);
</PRE>

<A NAME="CE"><H2>Content and Transfer Encoders and Decoders</H2>

Content codins are transformations applied to an entity object after
it was created in its original form. The Library handles two types of
codings:

<DL>
<DT><B>Content Codings</B>
<DD>Content codings values indicate an encoding transformation that
has been applied to a resource. Content cosings are primarily used to
allow a document to be compressed or encrypted without loosing the
identity of its underlying media type.

<DT><B>Content Transfer Codings</B>
<DD>Content transfer codings values are used to indicate an encoding
transformation that has been, can be, or may be need to be applied to
an enity body in order to ensure safe transport through the
network. This differs from a content coding in that the transfer
coding is a property of the message, not the original message.
</DL>

Both types of encodings use the same registration mechanism in the
Library which we describe below:

<H3>Encoders and Decoders</H3>

<EM>Encoders</EM> and <EM>decoders</EM> are subclassed from the <A
HREF="HTStream.html">generic stream class</A>. <EM>Encoders</EM> are
capable of adding a content coding to a data object and
<EM>decoders</EM> can remove a content coding.

<PRE>
typedef HTStream * HTCoder	(HTRequest *	request,
				 void *		param,
				 HTEncoding	coding,
				 HTStream *	target);
</PRE>

The <EM>encoding</EM> is the name of the encoding mechanism
reporesented as an <A HREF="HTAtom.html">atom</A>, for example "zip",
"chunked", etc. Encodings are registered in lists and content
encodings are separated from transfer encodings by registering them in
different lists.

<H3>The HTCoding Object</H3>

The <EM>HTCoding</EM> object represents a registered encoding together
with a encoder and a decoder.

<PRE>
typedef struct _HTCoding HTCoding;
</PRE>

<H3>Predefined Coding Types</H4>

We have a set of pre defined atoms for various types of content
encodings and transfer encodings. "chunked" is not exactly in the same
group as the other encodings such as "binary" but it really doesn't
make any difference as it is just a matter of how the words are
chosen. The first three transfer encodings are actually not encodings
- they are just left overs from brain dead mail systems.

<PRE>
#define WWW_CTE_7BIT		HTAtom_for("7bit")
#define WWW_CTE_8BIT		HTAtom_for("8bit")
#define WWW_CTE_BINARY		HTAtom_for("binary")

#define WWW_CTE_BASE64		HTAtom_for("base64")
#define WWW_CTE_MACBINHEX	HTAtom_for("macbinhex")
#define WWW_CTE_CHUNKED		HTAtom_for("chunked")

#define WWW_CE_COMPRESS		HTAtom_for("compress")
#define WWW_CE_GZIP		HTAtom_for("gzip")
</PRE>

<H3>Register Content Coders</H3>

There is no difference in registrering a content encoder or a content decoder,
it all depends on how you use the list of encoders/decoders.

<PRE>
extern BOOL HTCoding_add (HTList * 	list,
			 const char *	encoding,
			 HTCoder *	encoder,
			 HTCoder *	decoder,
			 double		quality);

extern void HTCoding_deleteAll (HTList * list);

extern const char * HTCoding_name (HTCoding * me);
</PRE>

<H2><A NAME="charset">Content Charsets</A></H2>

<H3>Register a Charset</H3>

<PRE>
extern void HTCharset_add (HTList *		list,
			   const char *		charset,
			   double		quality);
</PRE>

<H3>Delete a list of Charsets</H3>

<PRE>
typedef struct _HTAcceptNode {
    HTAtom *	atom;
    double	quality;
} HTAcceptNode;
</PRE>

<PRE>
extern void HTCharset_deleteAll	(HTList * list);
</PRE>

<A NAME="language"><H2>Content Languages</H2></A>

<H3>Register a Language</H3>

<PRE>
extern void HTLanguage_add (HTList *		list,
			    const char *	lang,
			    double		quality);
</PRE>

<H3>Delete a list of Languages</H3>

<PRE>
extern void HTLanguage_deleteAll (HTList * list);
</PRE>

<A NAME="global"><H2>Global Registrations</H2></A>

There are two places where these preferences can be registered: in a
<EM>global</EM> list valid for <B>all</B> requests and a
<EM>local</EM> list valid for a particular request only. These are
valid for <EM>all</EM> requests. See the <A HREF="HTReq.html">Request
Manager</A> fro local sets.

<H3>Converters and Presenters</H3>

The <EM>global</EM> list of specific conversions which the format
manager can do in order to fulfill the request.  There is also a <A
HREF="HTReq.html"><EM>local</EM></A> list of conversions which
contains a generic set of possible conversions.

<PRE>
extern void HTFormat_setConversion	(HTList * list);
extern HTList * HTFormat_conversion	(void);
</PRE>

<H3>Content Codings</H3>

<PRE>
extern void HTFormat_setContentCoding	(HTList * list);
extern HTList * HTFormat_contentCoding	(void);
</PRE>

<H3>Content Transfer Codings</H3>

<PRE>
extern void HTFormat_setTransferCoding	(HTList * list);
extern HTList * HTFormat_transferCoding	(void);
</PRE>

We also define a macro to find out whether a transfer encoding is
really an encoding or whether it is just a "dummy" as for example
7bit, 8bit, and binary.

<PRE>
#define HTFormat_isUnityTransfer(me) \
	((me)==NULL \
	|| (me)==WWW_CTE_BINARY ||  (me)==WWW_CTE_7BIT || (me)==WWW_CTE_8BIT)
</PRE>

<H3>Content Languages</H3>

<PRE>
extern void HTFormat_setLanguage	(HTList * list);
extern HTList * HTFormat_language	(void);
</PRE>

<H3>Content Charsets</H3>

<PRE>
extern void HTFormat_setCharset		(HTList * list);
extern HTList * HTFormat_charset	(void);
</PRE>

<H3>Delete All Global Lists</H3>

This is a convenience function that might make life easier.

<PRE>
extern void HTFormat_deleteAll (void);
</PRE>

<A NAME="Rank"><H2>Ranking of Accepted Formats</H2></A>

This function is used when the best match among several possible
documents is to be found as a function of the accept headers sent in
the client request.

<PRE>
typedef struct _HTContentDescription {
    char *	filename;
    HTFormat	content_type;
    HTLanguage	content_language;
    HTEncoding	content_encoding;
    HTEncoding	content_transfer;
    int		content_length;
    double	quality;
} HTContentDescription;

extern BOOL HTRank (HTList * possibilities,
		    HTList * accepted_content_types,
		    HTList * accepted_content_languages,
		    HTList * accepted_content_encodings);
</PRE>

<H2><A NAME="z3">The Content Type Stream Stack</A></H2>

This is the routine which actually sets up the content type
conversion. It currently checks only for direct conversions, but
multi-stage conversions are forseen.  It takes a stream into which the
output should be sent in the final format, builds the conversion
stack, and returns a stream into which the data in the input format
should be fed. If <CODE>guess</CODE> is true and input format is
<CODE>www/unknown</CODE>, try to guess the format by looking at the
first few bytes of the stream. <P>

<PRE>
extern HTStream * HTStreamStack (HTFormat	rep_in,
				 HTFormat	rep_out,
				 HTStream *	output_stream,
				 HTRequest *	request,
				 BOOL		guess);
</PRE>

<H3>Cost of a Stream Stack</H3>

Must return the cost of the same stack which HTStreamStack would set
up.

<PRE>
extern double HTStackValue	(HTList *	conversions,
				 HTFormat	format_in,
				 HTFormat	format_out,
				 double		initial_value,
				 long int	length);
</PRE>

<A NAME="CEStack"><H2>Content Encoding Stream Stack</H2></A>

When creating a coding stream stack, it is important that we keep the
right order of encoders and decoders. As an example, the HTTP spec
specifies that the list in the <EM>Content-Encoding</EM> header
follows the order in which the encodings have been applied to the
object. Internally, we represent the content encodings as <A
HREF="HTAtom.html">atoms</A> in a linked <A HREF="HTList.html">list
object</A>.<P>

The creation of the content coding stack is not based on quality
factors as we don't have the freedom as with content types. When using
content codings we <EM>must</EM> apply the codings specified or fail.

<PRE>
extern HTStream * HTContentCodingStack (HTEncoding	coding,
					HTStream *	target,
					HTRequest *	request,
					void *		param,
					BOOL		encoding);
</PRE>

Here you can provide a complete list instead of a single token. The list has to
be filled up in the order the _encodings_ are to be applied

<PRE>
extern HTStream * HTContentEncodingStack (HTList *	encodings,
					  HTStream *	target,
					  HTRequest *	request,
					  void *	param);
</PRE>

Here you can provide a complete list instead of a single token. The list has to
be in the order the _encodings_ were applied - that is, the same way that
_encodings_ are to be applied. This is all consistent with the order of the
Content-Encoding header.

<PRE>
extern HTStream * HTContentDecodingStack (HTList *	encodings,
					  HTStream *	target,
					  HTRequest *	request,
					  void *	param);
</PRE>

<A NAME="CTEStack"><H2>Content Transfer Encoding Stream Stack</H2></A>

Creating the transfer content encoding stream stack is not based on
quality factors as we don't have the freedom as with content
types. Specify whether you you want encoding or decoding using the
BOOL "encode" flag.

<PRE>
extern HTStream * HTTransferCodingStack (HTEncoding	encoding,
					 HTStream *	target,
					 HTRequest *	request,
					 void *		param,
					 BOOL		encode);
</PRE>

<PRE>
#endif /* HTFORMAT */
</PRE>

<HR>
<ADDRESS>
@(#) $Id$
</ADDRESS>
</BODY>
</HTML>
