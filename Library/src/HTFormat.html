<HTML>
<HEAD>
<!-- Changed by: Henrik Frystyk Nielsen, 15-Jul-1996 -->
  <TITLE>W3C Reference Library libwww Stream Pipe Manager</TITLE>
</HEAD>
<BODY>
<H1>
  The Stream Pipe Manager
</H1>
<PRE>
/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/
</PRE>
<P>
The Stream Pipe Manager is responsible for setting up the stream pipe from
the <A HREF="HTChannl.html">Channel Object</A> to the
<A HREF="HTReq.html">Request Object</A> when data is arriving, for example
as a response to s <A HREF="HTTP.html">HTTP</A> <B>Get</B> request. As data
arrives, we start to parse it and the more we know the more we can build
up our stream pipe. For example, in the case of HTTP, we first have a stream
that can parse the HTTP response line containing "<CODE>200 OK</CODE>". Then
we have a <A HREF="HTMIME.html">MIME parser</A> for handling the MIME headers.
When the MIME headers have been parsed, we know the content type and any
encoding of the MIME body. If we need to decode a chunked encoding then we
set up a chunked decoder, and if we have to parse a HTML object then we set
up a HTML parser.
<P>
The Format Manager is also responsible for keeping track of the
"<I>preferences</I>" of the application and/or user. It is an integral part
of the Web and HTTP, that the client application can express its preferences
as a set of "accept" headers in a HTTP request. This task is highly related
to the task mentioned above as we there use the modules that are registered
and here tell the remote server what we are capable of doing and what we
would prefer.
<P>
<B>Note</B>: The library <B>core</B> does not define any default decoders
or parsers - they are all considered part of the application. The library
comes with a default set of parsers including the ones mentioned above which
can be initiated using the functions in <A HREF="HTInit.html">HTInit
module</A>. There are different initialization functions for content type
parsers and content encodings respectively.
<P>
Currently there are four dimensions for handling "accept" headers:
<P>
<UL>
  <LI>
    <A HREF="#type">Content Type Converters and Presenters</A>
  <LI>
    <A HREF="#encoding">Content Encoders and Decoders</A>
  <LI>
    <A HREF="#charset">Content Charsets</A>
  <LI>
    <A HREF="#language">Natural Languages</A>
</UL>
<P>
The application can assign its preferences in two ways: either <I>locally</I>
to a single request or <I>globally</I> to all requests. The local assignment
can either <I>add to </I>or <I>override</I> the global settings depending
on how they are registered. All local registration is handled by the
<A HREF="HTReq.html">Request Object</A> and the global registration is handled
by the Format Manager
<P>
<UL>
  <LI>
    <A HREF="#global">Global Preferences</A>
</UL>
<P>
When data is arriving and the Format Manager is to build a stream pipe from
the <A HREF="HTChannl.html">HTChannel Object</A> to the
<A HREF="HTReq.html">Request Object</A>, it uses a special set of <I>stream
stack algorithms</I>. These algorithms take the complete set of content type
converters, for example, and finds the one best suited for the task. We currently
have three stream stack algorithms: one for content types, one for content
encodings, and one for content transfer encodings:
<P>
<UL>
  <LI>
    <A HREF="#CTStack">The Content Type Stream Stack</A>
  <LI>
    <A HREF="#CEStack">The Content Encoding Stream Stack</A>
  <LI>
    <A HREF="#CTEStack">The Content Transfer Encoding Stream Stack</A>
</UL>
<P>
This module is implemented by <A HREF="HTFormat.c">HTFormat.c</A>, and it
is a part of the <A HREF="http://www.w3.org/pub/WWW/Library/">W3C Reference
Library</A>.
<PRE>
#ifndef HTFORMAT_H
#define HTFORMAT_H

#include "<A HREF="HTUtils.html">HTUtils.h</A>"
#include "<A HREF="HTStream.html">HTStream.h</A>"
#include "<A HREF="HTAtom.html">HTAtom.h</A>"
#include "<A HREF="HTList.html">HTList.h</A>"
#include "<A HREF="HTAnchor.html">HTAnchor.h</A>"
#include "<A HREF="HTReq.html">HTReq.h</A>"
</PRE>
<H2>
  <A NAME="type">Content Type Converters and Presenters</A>
</H2>
<P>
All content type converters are subclassed from the Generic stream objetc.
That way, we allow the application to do very fast progressive display of
incoming data. In other words, the stream model of the Library provides data
as soon as it arrives from the network, the application does not have to
wait until the whole document has been down loaded before it starts parsing
it.
<H3>
  Content Type Converters
</H3>
<P>
A <CODE>converter</CODE> is a stream with a special set of parameters and
which is registered as capable of converting from a MIME type to something
else (maybe another MIME-type). A converter is defined to be a function returning
a stream and accepting the following parameters. The content type elements
are atoms for which we have defined a prototype.
<PRE>
typedef HTStream * HTConverter	(HTRequest *	request,
				 void *		param,
				 HTFormat	input_format,
				 HTFormat	output_format,
				 HTStream *	output_stream);
</PRE>
<H3>
  The HTPresentation Object
</H3>
<P>
A <CODE>presenter</CODE> is a module (possibly an external program) which
can present a graphic object of a certain MIME type to the user. That is,
<CODE>presenters</CODE> are normally used to present objects that the
<CODE>converters</CODE> are not able to handle. Data is transferred to the
external program using for example the
<A HREF="HTFWrite.html">HTSaveAndExecute</A> stream which writes to a local
file. Both presenters and converters are of the type
<A HREF="#converter">HTConverter</A>.
<PRE>
typedef struct _HTPresentation {
    HTFormat	rep;			     /* representation name atomized */
    HTFormat	rep_out;			 /* resulting representation */
    HTConverter *converter;	      /* The routine to gen the stream stack */
    char *	command;			       /* MIME-format string */
    char *	test_command;			       /* MIME-format string */
    double	quality;		     /* Between 0 (bad) and 1 (good) */
    double	secs;
    double	secs_per_byte;
} HTPresentation;
</PRE>
<H3>
  Basic Content type Converters
</H3>
<P>
We have a small set of basic converters that can be hooked in anywhere. They
don't "convert" anything but are nice to have.
<PRE>extern HTConverter HTThroughLine;
extern HTConverter HTBlackHoleConverter;
</PRE>
<H3>
  Predefined Content Types
</H3>
<P>
These macros (which used to be constants) define some basic internally referenced
representations. The <CODE>www/xxx</CODE> ones are of course not MIME standard.
They are internal representations used in the Library but they can't be exported
to other apps!
<PRE>
#define WWW_RAW		HTAtom_for("www/void")   /* Raw output from Protocol */
</PRE>
<P>
<CODE>WWW_RAW</CODE> is an output format which leaves the input untouched
<EM>exactly</EM> as it is received by the protocol module. For example, in
the case of FTP, this format returns raw ASCII objects for directory listings;
for HTTP, everything including the header is returned, for Gopher, a raw
ASCII object is returned for a menu etc.
<PRE>
#define WWW_SOURCE	HTAtom_for("*/*")
</PRE>
<P>
<CODE>WWW_SOURCE</CODE> is an output format which leaves the input untouched
<EM>exactly</EM> as it is received by the protocol module <B>IF</B> not a
suitable converter has been registered with a quality factor higher than
1 (for example 2). In this case the <EM>SUPER CONVERTER</EM> is preferred
for the raw output. This can be used as a filter effect that allows conversion
from, for example raw FTPdirectory listings into HTML but passes a MIME body
untouched.
<PRE>
#define WWW_PRESENT	HTAtom_for("www/present")
</PRE>
<P>
<CODE>WWW_PRESENT</CODE> represents the user's perception of the document.
If you convert to <CODE>WWW_PRESENT</CODE>, you present the material to the
user.
<PRE>
#define WWW_DEBUG	HTAtom_for("www/debug")
</PRE>
<P>
<CODE>WWW_DEBUG</CODE> represents the user's perception of debug information,
for example sent as a HTML document in a HTTP redirection message.
<PRE>
#define WWW_UNKNOWN     HTAtom_for("www/unknown")
</PRE>
<P>
<CODE>WWW_UNKNOWN</CODE> is a really unknown type. It differs from the real
MIME type <EM>"application/octet-stream"</EM> in that we haven't even tried
to figure out the content type at this point.
<P>
These are regular MIME types defined. Others can be added!
<PRE>
#define WWW_HTML 	HTAtom_for("text/html")
#define WWW_PLAINTEXT 	HTAtom_for("text/plain")
#define WWW_FORM	HTAtom_for("application/x-www-form-urlencoded")

#define WWW_MIME	HTAtom_for("message/rfc822")
#define WWW_MIME_HEAD	HTAtom_for("message/x-rfc822-head")
#define WWW_MIME_FOOT	HTAtom_for("message/x-rfc822-foot")

#define WWW_AUDIO       HTAtom_for("audio/basic")

#define WWW_VIDEO 	HTAtom_for("video/mpeg")

#define WWW_GIF 	HTAtom_for("image/gif")
#define WWW_JPEG 	HTAtom_for("image/jpeg")
#define WWW_TIFF 	HTAtom_for("image/tiff")
#define WWW_PNG 	HTAtom_for("image/png")

#define WWW_BINARY 	HTAtom_for("application/octet-stream")
#define WWW_POSTSCRIPT 	HTAtom_for("application/postscript")
#define WWW_RICHTEXT 	HTAtom_for("application/rtf")
</PRE>
<P>
We also have some MIME types that come from the various protocols when we
convert from ASCII to HTML.
<PRE>
#define WWW_GOPHER_MENU HTAtom_for("text/x-gopher")
#define WWW_CSO_SEARCH	HTAtom_for("text/x-cso")

#define WWW_FTP_LNST	HTAtom_for("text/x-ftp-lnst")
#define WWW_FTP_LIST	HTAtom_for("text/x-ftp-list")

#define WWW_NNTP_LIST   HTAtom_for("text/x-nntp-list")
#define WWW_NNTP_OVER	HTAtom_for("text/x-nntp-over")
#define WWW_NNTP_HEAD	HTAtom_for("text/x-nntp-head")

#define WWW_HTTP	HTAtom_for("text/x-http")
</PRE>
<P>
Finally we have defined a special format for our RULE files as they can be
handled by a special converter.
<PRE>
#define WWW_RULES	HTAtom_for("application/x-www-rules")
</PRE>
<H3>
  Register Presenters
</H3>
<P>
This function creates a presenter object and adds to the list of conversions.
These are the parameters :
<DL>
  <DT>
    conversions
  <DD>
    The list of <CODE>conveters</CODE> and <CODE>presenters</CODE>
  <DT>
    rep_in
  <DD>
    the MIME-style format name
  <DT>
    rep_out
  <DD>
    is the resulting content-type after the conversion
  <DT>
    converter
  <DD>
    is the routine to call which actually does the conversion
  <DT>
    quality
  <DD>
    A degradation faction [0..1]
  <DT>
    maxbytes
  <DD>
    A limit on the length acceptable as input (0 infinite)
  <DT>
    maxsecs
  <DD>
    A limit on the time user will wait (0 for infinity)
</DL>
<PRE>
extern void HTPresentation_add (HTList *	conversions,
				const char * 	representation,
				const char * 	command,
				const char * 	test_command,
				double		quality,
				double		secs, 
				double		secs_per_byte);

extern void HTPresentation_deleteAll	(HTList * list);
</PRE>
<H3>
  Register Converters
</H3>
<P>
This function creates a presenter object and adds to the list of conversions.
<DL>
  <DT>
    conversions
  <DD>
    The list of <CODE>conveters</CODE> and <CODE>presenters</CODE>
  <DT>
    rep_in
  <DD>
    the MIME-style format name
  <DT>
    rep_out
  <DD>
    is the resulting content-type after the conversion
  <DT>
    converter
  <DD>
    is the routine to call which actually does the conversion
  <DT>
    quality
  <DD>
    A degradation faction [0..1]
  <DT>
    maxbytes
  <DD>
    A limit on the length acceptable as input (0 infinite)
  <DT>
    maxsecs
  <DD>
    A limit on the time user will wait (0 for infinity)
</DL>
<PRE>
extern void HTConversion_add   (HTList *	conversions,
				const char * 	rep_in,
				const char * 	rep_out,
				HTConverter *	converter,
				double		quality,
				double		secs, 
				double		secs_per_byte);

extern void HTConversion_deleteAll	(HTList * list);
</PRE>
<H2>
  <A NAME="encoding">Content and Transfer Encoders and Decoders</A>
</H2>
<P>
Content codins are transformations applied to an entity object after it was
created in its original form. The Library handles two types of codings:
<DL>
  <DT>
    <B>Content Codings</B>
  <DD>
    Content codings values indicate an encoding transformation that has been
    applied to a resource. Content cosings are primarily used to allow a document
    to be compressed or encrypted without loosing the identity of its underlying
    media type.
  <DT>
    <B>Content Transfer Codings</B>
  <DD>
    Content transfer codings values are used to indicate an encoding transformation
    that has been, can be, or may be need to be applied to an enity body in order
    to ensure safe transport through the network. This differs from a content
    coding in that the transfer coding is a property of the message, not the
    original message.
</DL>
<P>
Both types of encodings use the same registration mechanism in the Library
which we describe below:
<H3>
  Encoders and Decoders
</H3>
<P>
<EM>Encoders</EM> and <EM>decoders</EM> are subclassed from the
<A HREF="HTStream.html">generic stream class</A>. <EM>Encoders</EM> are capable
of adding a content coding to a data object and <EM>decoders</EM> can remove
a content coding.
<PRE>
typedef HTStream * HTCoder	(HTRequest *	request,
				 void *		param,
				 HTEncoding	coding,
				 HTStream *	target);
</PRE>
<P>
The <EM>encoding</EM> is the name of the encoding mechanism reporesented
as an <A HREF="HTAtom.html">atom</A>, for example "zip", "chunked", etc.
Encodings are registered in lists and content encodings are separated from
transfer encodings by registering them in different lists.
<H3>
  The HTCoding Object
</H3>
<P>
The <EM>HTCoding</EM> object represents a registered encoding together with
a encoder and a decoder.
<PRE>
typedef struct _HTCoding HTCoding;
</PRE>
<P>
Predefined Coding Types We have a set of pre defined atoms for various types
of content encodings and transfer encodings. "chunked" is not exactly in
the same group as the other encodings such as "binary" but it really doesn't
make any difference as it is just a matter of how the words are chosen. The
first three transfer encodings are actually not encodings - they are just
left overs from brain dead mail systems.
<PRE>
#define WWW_CTE_7BIT		HTAtom_for("7bit")
#define WWW_CTE_8BIT		HTAtom_for("8bit")
#define WWW_CTE_BINARY		HTAtom_for("binary")

#define WWW_CTE_BASE64		HTAtom_for("base64")
#define WWW_CTE_MACBINHEX	HTAtom_for("macbinhex")
#define WWW_CTE_CHUNKED		HTAtom_for("chunked")

#define WWW_CE_COMPRESS		HTAtom_for("compress")
#define WWW_CE_GZIP		HTAtom_for("gzip")
</PRE>
<H3>
  Register Content Coders
</H3>
<P>
There is no difference in registrering a content encoder or a content decoder,
it all depends on how you use the list of encoders/decoders.
<PRE>
extern BOOL HTCoding_add (HTList * 	list,
			 const char *	encoding,
			 HTCoder *	encoder,
			 HTCoder *	decoder,
			 double		quality);

extern void HTCoding_deleteAll (HTList * list);

extern const char * HTCoding_name (HTCoding * me);
</PRE>
<H2>
  <A NAME="charset">Content Charsets</A>
</H2>
<H3>
  Register a Charset
</H3>
<PRE>
extern void HTCharset_add (HTList *		list,
			   const char *		charset,
			   double		quality);
</PRE>
<H3>
  Delete a list of Charsets
</H3>
<PRE>
typedef struct _HTAcceptNode {
    HTAtom *	atom;
    double	quality;
} HTAcceptNode;
</PRE>
<PRE>
extern void HTCharset_deleteAll	(HTList * list);
</PRE>
<H2>
  <A NAME="language">Content Languages</A>
</H2>
<H3>
  Register a Language
</H3>
<PRE>
extern void HTLanguage_add (HTList *		list,
			    const char *	lang,
			    double		quality);
</PRE>
<H3>
  Delete a list of Languages
</H3>
<PRE>
extern void HTLanguage_deleteAll (HTList * list);
</PRE>
<P>
<H2>
  <A NAME="global">Global Preferences</A>
</H2>
<P>
There are two places where these preferences can be registered: in a
<EM>global</EM> list valid for <B>all</B> requests and a <EM>local</EM> list
valid for a particular request only. These are valid for <EM>all</EM> requests.
See the <A HREF="HTReq.html">Request Manager</A> fro local sets.
<H3>
  Converters and Presenters
</H3>
<P>
The <EM>global</EM> list of specific conversions which the format manager
can do in order to fulfill the request. There is also a
<A HREF="HTReq.html"><EM>local</EM></A> list of conversions which contains
a generic set of possible conversions.
<PRE>
extern void HTFormat_setConversion	(HTList * list);
extern HTList * HTFormat_conversion	(void);

extern void HTFormat_addConversion (const char *	input_format,
				    const char *	output_format,
				    HTConverter *	converter,
				    double		quality,
				    double		secs, 
				    double		secs_per_byte);
</PRE>
<H3>
  Content Codings
</H3>
<PRE>
extern void HTFormat_setContentCoding	(HTList * list);
extern HTList * HTFormat_contentCoding	(void);

extern BOOL HTFormat_addCoding ( char *		encoding,
				 HTCoder *	encoder,
				 HTCoder *	decoder,
				 double		quality);
</PRE>
<H3>
  Content Transfer Codings
</H3>
<PRE>
extern void HTFormat_setTransferCoding	(HTList * list);
extern HTList * HTFormat_transferCoding	(void);

extern BOOL HTFormat_addTransferCoding ( char *		encoding,
					 HTCoder *	encoder,
					 HTCoder *	decoder,
					 double		quality);
</PRE>
<P>
We also define a macro to find out whether a transfer encoding is really
an encoding or whether it is just a "dummy" as for example 7bit, 8bit, and
binary.
<PRE>
#define HTFormat_isUnityTransfer(me) \
	((me)==NULL \
	|| (me)==WWW_CTE_BINARY ||  (me)==WWW_CTE_7BIT || (me)==WWW_CTE_8BIT)
</PRE>
<H3>
  Content Languages
</H3>
<PRE>
extern void HTFormat_setLanguage	(HTList * list);
extern HTList * HTFormat_language	(void);
</PRE>
<H3>
  Content Charsets
</H3>
<PRE>
extern void HTFormat_setCharset		(HTList * list);
extern HTList * HTFormat_charset	(void);
</PRE>
<H3>
  Delete All Global Lists
</H3>
<P>
This is a convenience function that might make life easier.
<PRE>
extern void HTFormat_deleteAll (void);
</PRE>
<H2>
  <A NAME="CTStack">The Content Type Stream Stack</A>
</H2>
<P>
This is the routine which actually sets up the content type conversion. It
currently checks only for direct conversions, but multi-stage conversions
are forseen. It takes a stream into which the output should be sent in the
final format, builds the conversion stack, and returns a stream into which
the data in the input format should be fed. If <CODE>guess</CODE> is true
and input format is <CODE>www/unknown</CODE>, try to guess the format by
looking at the first few bytes of the stream.
<P>
<PRE>
extern HTStream * HTStreamStack (HTFormat	rep_in,
				 HTFormat	rep_out,
				 HTStream *	output_stream,
				 HTRequest *	request,
				 BOOL		guess);
</PRE>
<H3>
  Cost of a Stream Stack
</H3>
<P>
Must return the cost of the same stack which HTStreamStack would set up.
<PRE>
extern double HTStackValue	(HTList *	conversions,
				 HTFormat	format_in,
				 HTFormat	format_out,
				 double		initial_value,
				 long int	length);
</PRE>
<H2>
  <A NAME="CEStack">Content Encoding Stream Stack</A>
</H2>
<P>
When creating a coding stream stack, it is important that we keep the right
order of encoders and decoders. As an example, the HTTP spec specifies that
the list in the <EM>Content-Encoding</EM> header follows the order in which
the encodings have been applied to the object. Internally, we represent the
content encodings as <A HREF="HTAtom.html">atoms</A> in a linked
<A HREF="HTList.html">list object</A>.
<P>
The creation of the content coding stack is not based on quality factors
as we don't have the freedom as with content types. When using content codings
we <EM>must</EM> apply the codings specified or fail.
<PRE>
extern HTStream * HTContentCodingStack (HTEncoding	coding,
					HTStream *	target,
					HTRequest *	request,
					void *		param,
					BOOL		encoding);
</PRE>
<P>
Here you can provide a complete list instead of a single token. The list
has to be filled up in the order the _encodings_ are to be applied
<PRE>
extern HTStream * HTContentEncodingStack (HTList *	encodings,
					  HTStream *	target,
					  HTRequest *	request,
					  void *	param);
</PRE>
<P>
Here you can provide a complete list instead of a single token. The list
has to be in the order the _encodings_ were applied - that is, the same way
that _encodings_ are to be applied. This is all consistent with the order
of the Content-Encoding header.
<PRE>
extern HTStream * HTContentDecodingStack (HTList *	encodings,
					  HTStream *	target,
					  HTRequest *	request,
					  void *	param);
</PRE>
<P>
<H2>
  <A NAME="CTEStack">Content Transfer Encoding Stream Stack</A>
</H2>
<P>
Creating the transfer content encoding stream stack is not based on quality
factors as we don't have the freedom as with content types. Specify whether
you you want encoding or decoding using the BOOL "encode" flag.
<PRE>
extern HTStream * HTTransferCodingStack (HTEncoding	encoding,
					 HTStream *	target,
					 HTRequest *	request,
					 void *		param,
					 BOOL		encode);
</PRE>
<PRE>
#endif /* HTFORMAT */
</PRE>
<P>
  <HR>
<ADDRESS>
  @(#) $Id$
</ADDRESS>
</BODY></HTML>
