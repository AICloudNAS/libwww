<HEADER>
<TITLE>HTFormat: The format manager in the WWW Library</TITLE>
<NEXTID N="10">
</HEADER>
<BODY>
<H1>Manage different document formats</H1>Here we describe the functions of
the HTFormat module which handles
conversion between different data
representations.  (In MIME parlance,
a representation is known as a content-type.
In WWW  the term "format" is often
used as it is shorter).<P>
This module is implemented by <A
NAME=z0 HREF="HTFormat.c">HTFormat.c</A>
. This hypertext document is used
to generate the <A
NAME=z8 HREF="HTFormat.h">HTFormat.h</A> inlude
file.
<H2>Preamble</H2>
<PRE>#ifndef HTFORMAT_H
#define HTFORMAT_H

#include "HTUtils.h"
#include <A
NAME=z7 HREF="HTStream.html">"HTStream.h"</A>
#include "HTAtom.h"
#include "HTList.h"

#ifdef SHORT_NAMES
#define HTOutputSource HTOuSour
#define HTOutputBinary HTOuBina
#endif

</PRE>
<H2>The HTFormat type</H2>We use the HTAtom object for holding
representations. This allows faster
manipulation (comparison and copying)
that if we stayed with strings.
<PRE>typedef HTAtom * HTFormat;
			
</PRE>These macros (which used to be constants)
define some basic internally referenced
representations.  The www/xxx ones
are of course not MIME standard.<P>
www/source  is an output format which
leaves the input untouched. It is
useful for diagnostics, and for users
who want to see the original, whatever
it is.
<PRE>			/* Internal ones */
#define WWW_SOURCE HTAtom_for("www/source")	/* Whatever it was originally*/

</PRE>www/present represents the user's
perception of the document.  If you
convert to www/present, you present
the material to the user. 
<PRE>#define WWW_PRESENT HTAtom_for("www/present")	/* The user's perception */

</PRE>The message/rfc822 format means a
MIME message or a plain text message
with no MIME header. This is what
is returned by an HTTP server.
<PRE>#define WWW_MIME HTAtom_for("www/mime")		/* A MIME message */
</PRE>www/print is like www/present except
it represents a printed copy.
<PRE>#define WWW_PRINT HTAtom_for("www/print")	/* A printed copy */

#define WWW_PLAINTEXT 	HTAtom_for("text/plain")
#define WWW_POSTSCRIPT 	HTAtom_for("application/postscript")
#define WWW_RICHTEXT 	HTAtom_for("application/rtf")
#define WWW_HTML 	HTAtom_for("text/html")
#define WWW_BINARY 	HTAtom_for("application/binary")

</PRE>We must include the following file
after defining HTFormat, to which
it makes reference.
<PRE>#include "HTAnchor.h"

</PRE>
<H2>The HTPresentation and HTConverter
types</H2>This HTPresentation structure represents
a possible conversion algorithm from
one format to annother.  It includes
a pointer to a conversion routine.
The conversion routine returns a
stream to which data should be fed.
See also <A
NAME=z5 HREF="#z3">HTStreamStack</A> which scans
the list of registered converters
and calls one. See the <A
NAME=z6 HREF="HTInit.html">initialisation
module</A> for a list of conversion routines.
<PRE>typedef struct _HTPresentation HTPresentation;

typedef HTStream * HTConverter PARAMS((
	HTPresentation *	pres,
	HTParentAnchor *	anchor,
	HTStream *		sink));
	
struct _HTPresentation {
	HTAtom* rep;		/* representation name atmoized */
	HTAtom* rep_out;	/* resulting representation */
	HTConverter *converter;	/* The routine to gen the stream stack */
	char *  command;	/* MIME-format string */
	float	quality;	/* Between 0 (bad) and 1 (good) */
	float   secs;
	float   secs_per_byte;
};

</PRE>The list of presentations is kept
by this module.  It is also scanned
by modules which want to know the
set of formats supported. for example.
<PRE>extern HTList * HTPresentations;

</PRE>
<H2>HTSetPresentation: Register a system
command to present a format</H2>
<H3>On entry,</H3>
<DL>
<DT>rep
<DD> is the MIME - style format name
<DT>command
<DD> is the MAILCAP - style command
template
<DT>quality
<DD> A degradation faction 0..1
<DT>maxbytes
<DD> A limit on the length acceptable
as input (0 infinite)
<DT>maxsecs
<DD> A limit on the time user
will wait (0 for infinity)
</DL>

<PRE>extern void HTSetPresentation PARAMS((
	CONST char * representation,
	CONST char * command,
	float	quality,
	float	secs, 
	float	secs_per_byte
));


</PRE>
<H2>HTSetConversion:   Register a converstion
routine</H2>
<H3>On entry,</H3>
<DL>
<DT>rep_in
<DD> is the content-type input
<DT>rep_out
<DD> is the resulting content-type
<DT>converter
<DD> is the routine to make
the stream to do it
</DL>

<PRE>
extern void HTSetConversion PARAMS((
	CONST char * 	rep_in,
	CONST char * 	rep_out,
	HTConverter *	converter,
	float		quality,
	float		secs, 
	float		secs_per_byte
));


</PRE>
<H2><A
NAME=z3>HTStreamStack:   Create a stack of
streams</A></H2>This is the routine which actually
sets up the conversion. It currently
checks only for direct conversions,
but multi-stage conversions are forseen.
It takes a stream into which the
output should be sent in the final
format, builds the conversion stack,
and returns a stream into which the
data in the input format should be
fed.  The anchor is passed because
hypertxet objects load information
into the anchor object which represents
them.
<PRE>extern HTStream * HTStreamStack PARAMS((
	HTFormat		format_in,
	HTFormat		format_out,
	HTStream*		stream_out,
	HTParentAnchor*		anchor));

</PRE>
<H2>HTStackValue: Find the cost of a
filter stack</H2>Must return the cost of the same
stack which HTStreamStack would set
up.
<H3>On entry,</H3>
<DL>
<DT>format_in
<DD> The fomat of the data to
be converted
<DT>format_out
<DD> The format required
<DT>initial_value
<DD> The intrinsic "value"
of the data before conversion on
a scale from 0 to 1
<DT>length
<DD> The number of bytes expected
in the input format
</DL>

<PRE>extern float HTStackValue PARAMS((
	HTFormat		format_in,
	HTFormat		rep_out,
	float			initial_value,
	long int		length));

#define NO_VALUE_FOUND	-1e20		/* returned if none found */

</PRE>
<H2><A
NAME=z1>HTCopy:  Copy a socket to a stream</A></H2>This is used by the protocol engines
to send data down a stream, typically
one which has been generated by HTStreamStack.
<PRE>extern void HTCopy PARAMS((
	int			file_number,
	HTStream*		sink));

	
</PRE>
<H2><A
NAME=c6>HTFileCopy:  Copy a file to a stream</A></H2>This is used by the protocol engines
to send data down a stream, typically
one which has been generated by HTStreamStack.
It is currently called by <A
NAME=z9 HREF="#c7">HTParseFile</A>
<PRE>extern void HTFileCopy PARAMS((
	FILE*			fp,
	HTStream*		sink));

	
</PRE>
<H2><A
NAME=c2>HTCopyNoCR: Copy a socket to a stream,
stripping CR characters.</A></H2>It is slower than <A
NAME=z2 HREF="#z1">HTCopy</A> .
<PRE>
extern void HTCopyNoCR PARAMS((
	int			file_number,
	HTStream*		sink));


</PRE>
<H2>Clear input buffer and set file number</H2>This routine and the one below provide
simple character input from sockets.
(They are left over from the older
architecure and may not be used very
much.)  The existence of a common
routine and buffer saves memory space
in small implementations.
<PRE>extern void HTInitInput PARAMS((int file_number));

</PRE>
<H2>Get next character from buffer</H2>
<PRE>extern char HTGetChararcter NOPARAMS;


</PRE>
<H2>HTParseSocket: Parse a socket given
its format</H2>This routine is called by protocol
modules to load an object.  uses<A
NAME=z4 HREF="#z3">
HTStreamStack</A> and the copy routines
above.  Returns HT_LOADED if succesful,
&lt;0 if not.
<PRE>extern int HTParseSocket PARAMS((
	HTFormat	format_in,
	HTFormat	format_out,
	HTParentAnchor	*anchor,
	int 		file_number,
	HTStream*	sink));

</PRE>
<H2><A
NAME=c1>HTParseFile: Parse a File through
a file pointer</A></H2>This routine is called by protocols
modules to load an object. uses<A
NAME=z4 HREF="#z3"> HTStreamStack</A>
and <A
NAME=c7 HREF="#c6">HTFileCopy</A> .  Returns HT_LOADED
if succesful, &lt;0 if not.
<PRE>extern int HTParseFile PARAMS((
	HTFormat	format_in,
	HTFormat	format_out,
	HTParentAnchor	*anchor,
	FILE		*fp,
	HTStream*	sink));

</PRE>
<H2>HTFormatInit: Set up default presentations
and conversions</H2>These are defined in HTInit.c or
HTSInit.c if these have been replaced.
If you don't call this routine, and
you don't define any presentations,
then this routine will automatically
be called the first time a conversion
is needed. However, if you explicitly
add some conversions (eg using HTLoadRules)
then you may want also to explicitly
call this to get the defaults as
well.
<PRE>extern void HTFormatInit NOPARAMS;

</PRE>
<H2>Epilogue</H2>
<PRE>extern BOOL HTOutputSource;	/* Flag: shortcut parser */
#endif

</PRE>end</A></BODY>
