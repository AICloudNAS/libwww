<HTML>
<HEAD>
<TITLE>Asyncronous Socket Management</TITLE>
<!-- Changed by: Henrik Frystyk Nielsen, 18-Sep-1995 -->
</HEAD>
<BODY>

<H1>Asyncronous Socket Management</H1>

<PRE>
/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/
</PRE>

This module contains the routines for handling the set of active
sockets currently in use by the multithreaded clients. It is an
internal module to the Library, the application interface is
implemented in the <A HREF="HTEvntrg.html">Event Module</A>. Look for
more information in the <A
HREF="http://www.w3.org/pub/WWW/Library/User/Architecture/">
Multithread Specifications</A>. <P>

This module is implemented by <A HREF="HTNet.c">HTNet.c</A>, and it is
a part of the <A HREF="http://www.w3.org/pub/WWW/Library/">W3C
Reference Library</A>.

<PRE>
#ifndef HTNET_H
#define HTNET_H
#include "HTReq.h"
</PRE>

<H2>The HTNet Object</H2>

The <CODE>HTNet</CODE> object is the core of the request queue
management. This object contains information about the socket
descriptor, the input read buffer etc. required to identify and
service a request. <P>

<PRE>
typedef struct _HTNet HTNet;
</PRE>

<H2>Request Termination Call Back Functions</H2>

The termination callback functions is a set of functions that can be
registered by the application to be called when a request has
terminated. There can be more than one callback function which are
called on turn and each callback function can be associated with a
status code of the request. For example one callback function can be
registered for HT_LOADED, another for HT_ERROR etc.

<H3>Register a Request Callback</H3>

Register a call back function that is to be called on every
termination of a request. Several call back functions can be
registered in which case all of them are called in the reverse order
of which they were registered (last one first). The status signifies
which call back function to call depending of the result of the
request. This can be

<DL>
<DT>HT_ERROR
<DD>An error occured
<DT>HT_LOADED
<DD>The document was loaded
<DT>HT_NO_DATA
<DD>OK, but no data
<DT>HT_RETRY
<DD>Retry request after at a later time
<DT>HT_ALL
<DD>All of above
</DL>

<PRE>
typedef int HTNetCallBack (HTRequest * request, int status);

extern BOOL HTNet_register (HTNetCallBack *cbf, int status);
</PRE>

<H3>Unregister</H3>

Unregister call back functions

<PRE>
extern BOOL HTNet_unregister (HTNetCallBack *cbf);
extern BOOL HTNet_unregisterAll (void);
</PRE>

<H2>Call the Call Back Functions</H2>

Call all the call back functions registered in the list IF not the
status is HT_IGNORE. The callback functions are called in the reverse
order of which they were registered (last one first). Returns YES if
OK, else NO.

<PRE>
extern BOOL HTNet_callback (HTRequest * me, int status);
</PRE>

<H2>Request Queue</H2>

The request queue ensures that no more than a fixed number of TCP
connections are open at the same time. If more requests are handed to
the Library, they are put into the pending queue and initiated when
sockets become free.

<H3>Number of Simultanous open TCP connections</H3>

Set the max number of simultanous sockets. The default value is
HT_MAX_SOCKETS which is 6. The number of persistent connections depend
on this value as a deadlock can occur if all available sockets a
persistent (see the <A HREF="HTDNS.html">DNS Manager</A> for more
information on setting the number of persistent connections). The
number of persistent connections can never be more than the max number
of sockets-2, so letting newmax=2 prevents persistent sockets.

<PRE>
extern BOOL HTNet_setMaxSocket (int newmax);
extern int  HTNet_maxSocket (void);
</PRE>

<H2>List Active Queue</H2>

Returns the list of active requests that are currently having an open
connection. Returns list of HTNet objects or NULL if error

<PRE>
extern HTList *HTNet_activeQueue (void);
</PRE>


<H2>List Pending Queue</H2>

Returns the list of pending requests that are waiting to become
active. Returns list of HTNet objects or NULL if error

<PRE>
extern HTList *HTNet_pendingQueue (void);
</PRE>

<H2>HTNet Object Creation and deletion methods</H2>

These methods are used from within the Request Manager and are not
normally to be used outside the Library kernel.

<H3>Create an Object</H3>

Create a new HTNet object as a new request to be handled. If we have
more than HTMaxActive connections already then put this into the
pending queue, else start the request by calling the call back
function registered with this access method.  Returns YES if OK, else
NO

<PRE>
extern BOOL HTNet_new (HTRequest * request, HTPriority priority);
</PRE>

<H2>Make an Object Wait</H2>

Let a net object wait for a persistent socket. It will be launched
from the HTNet_delete() function when the socket gets free.

<PRE>
extern BOOL HTNet_wait (HTNet *net);
</PRE>

<H3>Delete an Object</H3>

Deletes the HTNet object from the list of active requests and calls
any registered call back functions IF not the status is HT_IGNORE.
This is used if we have internal requests that the app doesn't know
about. We also see if we have pending requests that can be started up
now when we have a socket free. The callback functions are called in
the reverse order of which they were registered (last one first)

<PRE>
extern BOOL HTNet_delete (HTNet * me, int status);
</PRE>

<H3>Delete ALL HTNet Objects</H3>

Deletes all HTNet object that might either be active or pending We DO
NOT call the call back functions - A crude way of saying goodbye!

<PRE>
extern BOOL HTNet_deleteAll (void);
</PRE>

<H2>Killing requests</H2>

For those who can't help it ;-)

<H3>Kill a Request</H3>

Kill the request by calling the call back function with a request for
closing the connection. Does not remove the object. This is done by
HTNet_delete() function which is called by the load routine.  Returns
OK if success, NO on error

<PRE>
extern BOOL HTNet_kill (HTNet * me);
</PRE>

<H3>Kill ALL requests</H3>

Kills all registered (active+pending) requests by calling the call
back function with a request for closing the connection. We do not
remove the HTNet object as it is done by HTNet_delete().  Returns OK
if success, NO on error

<PRE>
extern BOOL HTNet_killAll (void);
</PRE>

<PRE>
#endif /* HTNET_H */
</PRE>

End of declaration module
</BODY>
</HTML>


