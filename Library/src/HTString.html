<HTML>
<HEAD>
<TITLE>String Handling</TITLE>
<!-- Changed by: Henrik Frystyk Nielsen,  2-Nov-1995 -->
</HEAD>
<BODY>

<H1>String Management</H1>

<PRE>
/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/
</PRE>

These functions provide functionality for case-independent string
comparison and allocations with copies etc. <P>

This module is implemented by <A HREF="HTString.c">HTString.c</A>, and
it is a part of the <A NAME="z10"
HREF="http://www.w3.org/pub/WWW/Library/">
W3C Reference Library</A>. <P>

<PRE>
#ifndef HTSTRING_H
#define HTSTRING_H

extern CONST char * HTLibraryVersion;	/* String for help screen etc */
</PRE>

<H2><A NAME="dyn">Dynamic String Manipulation</A></H2>

These two functions are dynamic versions of <CODE>strcpy</CODE> and
<CODE>strcat</CODE>. They use <CODE>malloc</CODE> for allocating space
for the string. If <CODE>StrAllocCopy</CODE> is called with a non-NULL
dest, then this is freed before the new value is assigned so that only
the <EM>last</EM> string created has to be freed by the user. If
<CODE>StrAllocCat</CODE> is called with a NULL pointer as destination
then it is equivalent to <CODE>StrAllocCopy</CODE>.

<PRE>
#define StrAllocCopy(dest, src) HTSACopy (&amp;(dest), src)
#define StrAllocCat(dest, src)  HTSACat  (&amp;(dest), src)

extern char * HTSACopy (char **dest, CONST char *src);
extern char * HTSACat  (char **dest, CONST char *src);
</PRE>

<H2><A NAME="utils">Case-insensitive String Comparison</A></H2>

The usual routines (comp instead of cmp) had some problem.

<PRE>
extern int strcasecomp  (CONST char *a, CONST char *b);
extern int strncasecomp (CONST char *a, CONST char *b, int n);
</PRE>

<H2>String Comparison with Wild Card Match</H2>

String comparison function for file names with one wildcard * in the
template. Arguments are:

<DL>
<DT>tmpl
<DD>is a template string to match the name against.  agaist, may
contain a single wildcard character * which matches zero or more
arbitrary characters.
<DT>name
<DD>is the name to be matched agaist the template.
</DL>

returns	 YES, if filename matches the template, else NO

<PRE>
extern BOOL HTStringMatch (CONST char * tmpl, CONST char * name);
extern BOOL HTStringCaseMatch (CONST char * tmpl, CONST char * name);
</PRE>

<H2>Case-insensitive strstr</H2>

This works like <CODE>strstr()</CODE> but is not case-sensitive.

<PRE>
extern char * strcasestr (char * s1, char * s2);
</PRE>

<H2>Strip white space off a string</H2>

Return value points to first non-white character, or to '/0' if
none. All trailing white space is OVERWRITTEN with zero.

<PRE>
extern char * HTStrip (char * s);
</PRE>

<H2>Next word or quoted string</H2>

This function returns a RFC822 word separated by space, comma, or
semi-colons.

<PRE>
extern char * HTNextField (char** pstr);
</PRE>

<H2>RFC1123 Date/Time Stamp String</H2>

Returns a pointer to a static area!

<PRE>
extern CONST char *HTDateTimeStr (time_t *calendar, BOOL local);
</PRE>

<H2>Date used for directory listings</H2>

<PRE>
extern BOOL HTDateDirStr (time_t * time, char * str, int len);
</PRE>

<H2>Timezone Offset</H2>

Calculates the offset from GMT in seconds. This is called from <A
HREF="HTReq.html#Library">HTLibInit()</A>.

<PRE>
extern long HTGetTimeZoneOffset (void);
</PRE>

<H2>Parse a Date/Time String</H2>

Converts a string representation in GMT to a local representation of
localtime <CODE>time_t</CODE>.

<PRE>
extern time_t HTParseTime (CONST char * str);
</PRE>


<H2>Unique Message-ID String</H2>

<PRE>
extern CONST char *HTMessageIdStr (void);
#endif
</PRE>

<H2>Converts an Integer to a String using Prefix</H2>

In computer-world 1K is 1024 bytes and 1M is 1024K -- however,
sprintf() still formats in base-10.  Therefore I output only until
999, and then start using the next unit.  This doesn't work wrong,
it's just a feature.  The conversion is done in "str" which must be
large enough to contain the result.

<PRE>
extern void HTNumToStr (unsigned long n, char *str, int len);
</PRE>

<H2>Conversion between URLs and Local File Names</H2>

These are two functions that separate the URL naming syntax from
platform dependent file naming schemes. If you are porting the code to
a new platform, you probably have to do some translation here.

<H3>Convert file URLs into a local representation</H3>

The URL has already been translated through the rules in get_physical
in HTAccess.c and all we need to do now is to map the path to a local
representation, for example if must translate '/' to the ones that
turn the wrong way ;-) Returns local file (that must be freed by
caller) if OK, else NULL.

<PRE>
extern char * HTWWWToLocal (CONST char * url, CONST char * base);
</PRE>

<H3>Convert a local file name into a URL</H3>

Generates a WWW URL name from a local file name or NULL if error.
Returns URL (that must be freed by caller) if OK, else NULL.

<PRE>
extern char * HTLocalToWWW (CONST char * local);
</PRE>

End of declaration module

</BODY>
</HTML>
