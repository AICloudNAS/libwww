<HTML>
<HEAD>
  <!-- Changed by: Henrik Frystyk Nielsen, 17-Apr-1996 -->
  <TITLE>W3C Sample Code Library libwww MIME/RFC822 Parsers</TITLE>
</HEAD>
<BODY>
<H1>
  MIME Parsers
</H1>
<PRE>
/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/
</PRE>
<P>
The MIME parser stream presents a MIME document with a header and possibly
a footer. It recursively invokes the format manager to handle embedded formats
like MIME multipart. As well as stripping off and parsing the headers, the
MIME parser has to parse any weird MIME encodings it may meet within the
body parts of messages, and must deal with multipart messages.
<P>
This module is implemented to the level necessary for operation with WWW,
but is not currently complete for any arbitrary MIME message.
<P>
This module is implemented by <A HREF="HTMIME.c">HTMIME.c</A>, and it is
a part of the <A HREF="http://www.w3.org/Library/"> W3C Sample Code
Library</A>.
<PRE>
#ifndef HTMIME_H
#define HTMIME_H

#include "HTStream.h"
#include "HTFormat.h"
</PRE>
<H3>
  How to deal with "application/octetstream" etc.
</H3>
<P>
When the MIME parser can't find a target stream, for example because the
format is application/octetstream, or it has a content encoding or
transfer encoding that we don't know about then it has to get rid of the
data in some other fashion, for example by dumping it to local disk. The
following two functions allow you to set and get the local file save stream.
<P>
Libwww provides a default implementation as <A
HREF="HTFSave.html">HTSaveLocally</A> which you may want to use.
<PRE>
extern void HTMIME_setSaveStream (HTConverter * save_stream);
extern HTConverter * HTMIME_saveStream (void);
</PRE>

<H3>
  MIME header parser stream
</H3>
<P>
This stream parses a complete MIME header and if a content type header is
found then the stream stack is called. Any left over data is pumped right
through the stream.
<PRE>
extern HTConverter HTMIMEConvert;
</PRE>
<H3>
  MIME Header ONLY parser stream
</H3>
<P>
This stream parses a complete MIME header and then returnes HT_PAUSE. It
does not set up any streams and resting data stays in the buffer. This can
be used if you only want to parse the headers before you decide what to do
next. This is for example the case in a server app.
<PRE>
extern HTConverter HTMIMEHeader;
</PRE>
<H3>
  MIME Footer ONLY parser
</H3>
<P>
Parse only a footer, for example after a chunked encoding.
<PRE>
extern HTConverter HTMIMEFooter;
</PRE>
<H3>
  MIME 1xx Continue Header Parser
</H3>
<P>
When parsed the header it returns HT_CONTINUE
<PRE>
extern HTConverter HTMIMEContinue;
</PRE>
<H3>
  Partial MIME Response parser
</H3>
<P>
In case we sent a <I>Range conditional GET</I> we may get back a partial
response. This response must be appended to the already existing cache entry
before presented to the user. That is, first we load the cached object and
pump it down the pipe and then the new data follows. Only the latter part
gets appended to the cache, of course.
<PRE>
extern HTConverter HTMIMEPartial;
</PRE>
<PRE>
#endif
</PRE>
<P>
  <HR>
<ADDRESS>
  @(#) $Id$
</ADDRESS>
</BODY></HTML>
