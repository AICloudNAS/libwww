<HTML>
<HEAD>
<TITLE>Using the W3C Reference Library</TITLE>
<!-- Changed by: Henrik Frystyk Nielsen, 23-Aug-1995 -->
</HEAD>  
<BODY>

<A HREF="../../../"><IMG SRC="../../../Icons/WWW/WWW48x.gif" ALT="WWW"></A>
<A HREF="../../"><IMG SRC="../../../Icons/WWW/Lib48x.gif" ALT="Lib"></A>
<IMG SRC="../../../Icons/WWW/guide48x.gif" ALT="Using">

<H1>Using the W3C Reference Library</H1>

<IMG SRC="../../../Icons/WWW/construction.gif" ALT="WIP"> This paper
is still under construction. Comments are welcome at <A
HREF="mailto:libwww@w3.org">libwww@w3.org</A></P>

This is the user guide documentation describing the W3C Reference
library. It concentrates on the API and how the application programmer
can use the Library. It also describes who is responsible for memory
management and when things can be initialized etc. It is basically a
filteret version of the <A HREF="../Guide/">Internals</A> document
where only the "public" functions are described. This document is the
second of three documents that each describes different aspects of the
Library:

<DL>

<DT><A HREF="../Architecture/"><IMG ALT="Architecture" SRC="../../../Icons/WWW/Spec48x.gif"></A> <B>The Architecture</B>

<DD>The current document is the first in the series and it describes
the architecture of the Library without referring directly to the code
itself. This is the "designer view" where bugs are a unknown
phenomenon.

<DT><A HREF="./"><IMG SRC="../../../Icons/WWW/guide48x.gif" ALT="Using"></A> <B>The User's Guide</B>

<DD>The second document introduces the "official" API of the
Library. This document represents the "User's view" and should be
sufficient to use the Library without being aware of what's going on
underneeth the interface. It is also the API that is least exposed to
changes. The description contains a set of examples.

<DT><A HREF="../Guide/"><IMG ALT="Internals" SRC="../../../Icons/WWW/Tang48x.gif"></A> <B>The Internals and Programmer's Guide</B>

<DD>The last document in the serie presents all modules in the Library
regardles if they are part of the API described in the User's Guide or
not. This is also known as the "hacker's view" of the Library.

</UL>

<H2>Table of Contents</H2> 
<OL>
<LI><A HREF="Startup.html">Getting Started</A>
<LI><A HREF="Prefs.html">Setting Up Preferences for Language, Charset etc.</A>
<LI><A HREF="Bind.html">Make Bindings to the local File system</A>
<LI><A HREF="Methods.html">Registering Access Schemes</A>
<LI><A HREF="Proxy.html">Registering Proxy Servers and Gateways</A> <P>

<LI><A HREF="Anchors.html">Anchor Objects</A>
<LI><A HREF="Request.html">Request Objects</A>
<LI><A HREF="HyperDoc.html">HyperDoc Objects</A><P>

<LI><A HREF="Access.html">The Access Manager</A>
<LI><A HREF="Protocol.html">The Protocol Manager</A>
<LI><A HREF="Streams.html">The Format Manager</A>
<LI><A HREF="Cache.html">The Cache Manager</A>
<LI><A HREF="Error.html">The Error Cache</A>
<LI><A HREF="Event.html">The Event Manager</A><P>

<LI><A HREF="Logging.html">The Log Module</A>
<LI><A HREF="History.html">The History Module</A>
<LI><A HREF="MIME.html">The HTTP/MIME Parser</A>
<LI><A HREF="HTML.html">The HTML Parser</A>
<LI><A HREF="Override.html">Application Specific Modules</A>
<LI><A HREF="Flags.html">Global Flags and special Modes</A>
</OL>


<H1>Getting Started</H1>

The Library distribution package can be obtained from the <A
HREF="../../">Library status page</A> and it includes all source files
and some <A HREF="../../../README.html">README</A> files describing
what the package contains. There is also an online "<A
HREF="../Installation.html">Installation Guide</A>" explaining how to
unpack and compile the Library. As new versions of the Library are
released frequently, it is recommended that you verify that the
version is up to date by looking into the "Version.Make" file in the
"Implementation" directory of the Library and compare it with the
information given at the <A HREF="../../">Library status page</A>.<P>

From version 3.0, the include file "<A
HREF="../../Implementation/WWWLib.html">WWWLib.h</A>" is the only
include file which is required in order to use the Library.  This file
contains all the functionality that is publicly available, but as the
architecture is currently very exposed, this includes most of the
modules in the Library itself.  Apart from this, only two functions
are necessary in order to initialize and cleanup the Library
respectively:

<DL>

<DT><CODE>BOOL HTLibInit()</CODE>

<DD>This function initializes memory, file descriptors, interrupt
handlers etc. By default it also calls initialization functions for
all the dynamic modules in the Library. The dynamic modules are
described in "<A HREF="../Architecture/DesignModel.html">Libwww
Architecture</A>". A major part of the User's Guide is to describe how
the Library can be configured, both at run time and at compile time,
and the dynamic modules are an important part of the Library
configuration.

<DT><CODE>BOOL HTLibTerminate()</CODE>

<DD>Cleans up the memory and closes open file descriptors.

</DL>

It is essential that <CODE>HTLibInit()</CODE> is the first call to the
Library and <CODE>HTLibTerminate()</CODE> is the last as the behavior
otherwise is undefined. As an example, a minimal application will look
like this:

<PRE>
	#include &lt;WWWLib.h>
	/* Other initializations */

	int main()
	{
		HTLibInit();

		/* Application stuff */

		HTLibTerminate();
		return 0;
	}
</PRE>

<H1>Request Preferences</H1>

This section describes how to setup preferences for the representation
of a data object when requesting it from the network. The
representation of a data object is closely related to the format
negotiation in the <A HREF="../../../Protocols/">HTTP protocol</A> as
each dimension can be expressed as an "accept-*" header in an HTTP
request. The Library supports the following dimensions:

<UL>
<LI>The preferred natural langauge of the data object
<LI>The media type in which a data object should be rendered
<LI>The preferred content encodings (or supported)
<LI>The preferred character set
</UL>

Preferences can be registered in two ways: As a <EM>global</EM> list
which applies to all requests and a <EM>local</EM> list which is bound
to a specific request. The global and local lists are simply added
when the preferences for a request are converted to a set of
"accept-*" headers. There is currently no means or overriding global
preferences with the local preferences.</P>

It is important to note that <EM>none</EM> of the preferences are
enabled automatically by the Library - it is for the application to
specify as the preferences can change from request to
request. However, the Library has a set of default initialization
functions that make it easy for the application to set the preferences
that are directly supported by the Library. These are all located in
the <A HREF="../../Implementation/HTInit.html">HTInit module</A> and
can be modified to suit a particular application.</P>

<H3>Natural Languages</H3>

The user's preferences of natural languages can as converters and
presenters be registered both globally for all requests and locally
for a single request. The global list is called
<CODE>HTLanguages</CODE>, and the local list is a part of the <A
HREF="../../Implementation/HTAccess.html#z1">HTRequest structure
</A>as described in section <A HREF="#request">Issue an Request</A>
but in contrast to the converters there is no initialization function
in the <A HREF="../../Implementation/HTInit.html">HTInit module</A>.
Preferences for natural languages can be added individually to both
the local and global list using the functions:</P>

<PRE>
	HTAcceptLanguage()
</PRE>

<H3>Setting up the Media Types</H3>

The media types are handled by a set of converters and presenters. A
converter is a stream that can convert the rendition of a data object
from one format to another. A presenter is a stream that calls an
external program, for example a post script viewer or an audio program
for presenting the data obejct. Converters and presenters are special in that they both describe the preferred set of media types to be requested in a HTTP request and how a 


Both converters and presenters take
part in the stream stack algorithm that finds the best conversion of
the media type of a data object. The difference is that presenters
depend on external viewers for the presentation of the graphic object
whereas converters use internal modules in the Library and they do not
necessarily have to present the graphic object to the user. The
Library has two initialization functions which are defined in the <A
HREF="../../Implementation/HTInit.html" >HTInit module</A> as
described in the section <A HREF="#start">Get Started</A> The two
functions for setting up a list of default converters and presenters
respectively are: </P>

<PRE>
	void HTConverterInit(HTList *list);
	void HTPresenterInit(HTList *list);
</PRE>

Converters and presenters can be registered both globally for all
requests and locally for a single request. The global list is called
<CODE>HTConversions</CODE>, and the local list is a part of the <A
HREF="../../Implementation/HTAccess.html#z1">HTRequest structure
</A>as described in section <A HREF="#request">Issue an Request</A>.
This can be used to set up a global set of basic converters and a
local set of additional converters or presenters for a single
request. In the Line Mode Browser this is used to distinguish between
running in interactive mode or non-interactive mode. In the latter
mode, no external presenters are allowed, whereas this is a normal
part of the interactive mode. Hence the global set is the list of
converters and the local list is the list of presenters if running in
interactive mode:</P>

<PRE>
	HTConverterInit(HTConversions);			/* Set up global list */
	if (HTInteractive)
		HTPresenterInit(request->conversions);	/* Local list */
</PRE>

Converters and presenters can both be added individually to both the
local and global list using the functions:</P>

<PRE>
	HTSetPresentation()
	HTSetConversion()
</PRE> 

The initialization functions are in fact only a compiled list of calls
to these function.</P>

<H3>Encodings</H3>

The set of encoding and decoding streams are in the same category as
converters and presenters, but the Library does currently not provide
any encoders or decoders. Therefore there is no initialization
function in the <A HREF="../../Implementation/HTInit.html" >HTInit
module</A>. However, as for converters and presenters encodings and
decodings capabilities can be registered both globally for all
requests and locally for a single request. The global list is called
<CODE>HTEncodings</CODE>, and the local list is a part of the <A
HREF="../../Implementation/HTAccess.html#z1">HTRequest structure</A>
as described in section <A HREF="#request">Issue an Request</A>.
Encoders can be added individually to both the local and global list
using the functions:

<PRE>
	HTAcceptEncoding()</PRE>

<H3>Charsets</H3>

The user's preferences of chracter sets (a parameter on the content
type) can as converters and presenters be registered both globally for
all requests and locally for a single request. The global list is
called <CODE>HTCharsets</CODE>, and the local list is a part of the <A
HREF="../../Implementation/HTAccess.html#z1">HTRequest structure
</A>as described in section <A HREF="#request">Issue an
Request</A>. As for the list of natural languages there is no
initialization function in the <A
HREF="../../Implementation/HTInit.html">HTInit module</A>.
Preferences for charsets can be added individually to both the local
and global list using the functions:</P>

<PRE>
	void HTAcceptCharset(HTList *list, const char *charset, double quality);
</PRE>

<H1>Bindings to the local File system</H1>

Client applications have access to the local filesystem using
<EM>file</EM> URLs and server applications has inherently a close
connection to the local file system from which it is serving files to
the requesting parties. The binding betweeen a file and its
representation internally in the Library, that is the content-type,
natural language, and encoding is maintained by the <A
HREF="../../Implementation/HTBind.html">HTBind module</A>. The current
implementation of this module bases the binding on file suffixes, but
the module is separated so that other kind of bindings can be
implemented, for example using a database. The set of suffix
delimiters is normally a function of the current platform, but can at
any time be modified, so that for example the characters ".", "_", and
"+" can be defined as delimiters. </P>


As for the converters and presenters, the Library has a default set of
bindings between media types and file name extensions but the
difference is that the bindings are initialized at start up time in
the <CODE>HTLibInit()</CODE> function, and hence does not have to be
done explicitly by the application.  However, new bindings can be set
up using the methods:</P>

<PRE>
	HTBind_setType()
	HTBind_setEncoding()
	HTBind_setLanguage()
</PRE>

If the Library is to handle a file that is not described by
the binding rules, it reads the first part of the data object and try
and guess the media type. This is an internal operation in the Library
and does not require any interaction with the application.</P>

<H1><A NAME="methods">Enabling Access Methods</A></H1>

The Library handles a wide set of Internet Protocols as well as access
to the local file system. The current set of access methods supported
are: HTTP, FTP, Gopher, telnet, rlogin, NNTP and WAIS. All protocol
modules are dynamic modules and each module can be dynamically bound
to an access scheme as described in section <A HREF="#arc"
>Architectural Overview</A>. As an example, the URL:

<PRE>
	http://www.w3.org/
</PRE>

has the access scheme <EM>http</EM> and can be bound to the
<A HREF="../../Implementation/HTTP.html">HTTP module</A>. The binding
between a protocol module and an access method is by default done at
start up time in the <CODE>HTLibInit()</CODE> where the Library enables
all the access schemes that it provides services for. The application
can change the default behavior by providing its own initialization of
the binding between protocol modules and access methods. This can be
done in order to make applications with a limited set of Internet access
methods available or to add new protocol modules to the Library. There
are two ways of doing this:

<UL>

<LI>Disabling any initialization of the protocol modules in the
<CODE>HTLibInit()</CODE> function by using the <CODE>HT_NO_INIT</CODE>
preprocessor define as described in <A HREF="Flags.html">Global Flags</A>

<LI>Overriding the <A HREF="../../Implementation/HTInit.html">HTInit
module</A> by providing a new definition as described in <A
HREF="#override">Application Specific Modules</A>

</UL>

A single protocol module can be initialized using the function</P>

<PRE>
	HTRegisterProtocol()
</PRE>

One special case is the support for access to <A
HREF="../../../../Products/WAIS/">WAIS</A> databases. If native
support for access to a WAIS database is desired, the application must
be linked with a <A HREF="http://www.cnidr.org/" >WAIS library</A> in
which case the <A HREF="../../Implementation/HTWAIS.c"> HTWAIS</A>
module will be compiled into the Library as the interface between the
W3C Reference Library and the WAIS library. This can be done by
enabling the following lines in the <A
HREF="../Platform/Porting.html"> <EM>Makefile.include</EM></A> which
is the platform specific part of the <EM>Makefile</EM> created by the
<EM>BUILD</EM> script:

<PRE>
	WAIS = ../../../freeWAIS-0.3
	WAISLIB =  $(WAIS)/bin/client.a $(WAIS)/bin/wais.a
	MATHLIB = -lm
	WAISINC = -I$(WAIS)/ir
	WAISCFLAGS = -DDIRECT_WAIS
	HTWAIS = $(WTMP)/Library/$(WWW_MACH)/HTWAIS.o
</PRE>

It is important that the whole Library is rebuilt when doing this. In
case direct WAIS support is not present, the Library looks for a <A
HREF="../../../Gateways/WAISGate.html">WAIS gateway</A> in order to
handle the request and if no WAIS gateway is specified, the default
destination is defined as <A
HREF="wais://www.w3.org:8001/">wais://www.w3.org:8001/</A> where a
WAIS gateway is accepting connections.

<H1>Registering Proxy Servers and Gateways</H1>

An application can indirectly support an access method by redirecting
the request to either a proxy or a gateway. The difference between a
proxy server and a gateway is subtle and is described in <A
HREF="../Guide/Config.html#proxy">Internals and Programmer's
Guide</A>, but it does not affect the application using the Library
and the redirection is normally transparent to the user. The Library
supports both proxies and gateways through the <A
HREF="../../Implementation/HTProxy.html" >HTProxy module</A> and all
requests can be redirected to a proxy or a gateway, even requests on
the local file system. Of course, the Library can also be used in
proxy or gateway applications which in terms can use other proxies or
gateways so that a single request can be passed through a series of
intermediate agents.<P>

The set of public function to registere a gateway or a proxy are as
follows:

<PRE>
	BOOL HTProxy_setProxy(const char *access,const char *proxy);
	BOOL HTProxy_setNoProxy(const char *host, CONST char *access, unsigned port);
	BOOL HTProxy_setGateway(const char *access, const char *gate);
</PRE>

The <EM>no_proxy</EM> can be used to avoid contactinga proxy server
for a particular host name or domain name. The access method and port
number is optional. The behavior of the Library can be modified using
the preprocessor defines <CODE>HT_NO_RULES</CODE> and
<CODE>HT_NO_PROXY</CODE> as explained in section <A
HREF="#flags">Global Flags</A>

<H2>Using Environment Variables</H2>

Version 3.1 is the first version of the Library where proxies ans
gateways are not handled directly via environment variables, and for
backwards compatibility, there is a function in the <A
HREF="../../Implementation/HTProxy.html">HTProxy module</A> that reads
the environment variables:

<PRE>
	HTProxy_getEnvVar()
</PRE>

The format of the environmanet variables is as follows:

<DL>

<DT><CODE>WWW_&lt;access&gt;_GATEWAY</CODE>

<DD>Definition of a gateway. Note that a WAIS gateway can be defined
this way to change the default gateway at <A
HREF="wais://www.w3.org:8001/"> wais://www.w3.org:8001/</A>.

<DT><CODE>&lt;access&gt;_proxy</CODE>

<DD>Definition of a proxy server

<DT><CODE>no_proxy</CODE>

<DD>This is a comma separated list of remote servers where a proxy
server should <EM>not</EM> be consulted for handling the request. An
example is

<PRE>
	no_proxy="cern.ch,ncsa.uiuc.edu,some.host:8080"
	export no_proxy
</PRE>

</DL>

<CODE>&lt;access&gt;</CODE> is the specific access scheme and it is
case sensitive as access schemes in URIs are case sensitive. Proxy
servers have precedence over gateways, so if both a proxy server and a
gateway has been defined for a specific access scheme, the proxy
server is selected to handle the request.<P>

It is important to note that the usage of proxy servers or gateways is
an extension to the binding between an access scheme and a protocol
module. An application can be set up to redirect all URLs with a
specific access scheme without knowing about the semantics of this
access scheme or how to access the information directly. That way,
powerful client applications can be built having direct support for,
for example, HTTP only.

<H1>Using Anchors</H1>

<UL>
<LI>what do they represent
<LI>where and when to use
<LI>How to create and handle
<LI>relations between links
<LI>memory management
</UL>

<H1>The Request Object</H1>

Before issuing a request to the Library, the application must create a
<A HREF="../../Implementation/HTRequest.html">HTRequest structure</A>.
This structure is one of the main structures in the Library and
contains all information required to request a URL. A part of the
information can be modified by the user, and this section describes
how to do this. The most important parts of the management of the
request structure consist of the following methods (unfortunately not
all methods are functions yet but require a direct assignment of a
field in the) structure:

<H3>Creating a Request Structure</H3>

First a new structure must be created using the function

<PRE>
	HTRequest_new()
</PRE>

The request structure is created with a set of default values that in
most cases are sufficient to issue a request. The most important
defaults are:

<UL>
<LI>The method used is <CODE>GET</CODE>
<LI>By default, all natural languages are accepted
<LI>No explicit converters or presenters are initialized apart from the
ones already  set up in the global list as described in section <A HREF="#stream"
>The Stream Object</A>
<LI>When the data arrives as a result of the request a graphic object
is created and presented to the user. 
<LI>The HTTP module uses non-blocking I/O, that is either <B>Passive
mode</B> or <B>Active Mode</B>.
</UL>

It is normally not advisable to reuse a request structure, and
it is impossible if a multithreaded model is used where several requests
can be issued simultaneously. 

<H3>Deleting a Request Structure</H3>

A request structure is removed from memory by using the function

<PRE>
	HTRequest_delete()</PRE>

Note that the anchor does still exist and
any cached version of the object  is still accessible. The request
structure does not explicitly contain information about graphic objects,
only what is required to access the information.


<H3>Selecting the Method</H3>

The method used in the request (<CODE> GET</CODE>, <CODE>HEAD</CODE>,
<CODE>PUT</CODE>, <CODE>POST</CODE> etc) can be changed explicitly but
not independently of which action is to be performed. This requires a
basic understanding of what methods are similar in behavior. Currently
the following methods can be used with the same set of methods:

<UL>
<LI><CODE>GET</CODE> and <CODE>HEAD</CODE>
<LI><CODE>PUT</CODE> and <CODE>POST</CODE>
</UL>

These are also the methods that are directly supported by the
Library. Other methods will be supported in future versions.  Two
functions can be used to manage the method for a request:


<PRE>	HTRequest_setMethod()
	HTRequest_getMethod()
</PRE>

<H3>Changing Destination of a Data Object</H3>

When data is retrieved by the network, either via the network or the
local file system it is passed over to the client via the stream chain
as described in section <A HREF="#stream">Stream, Converters, and
Media Types</A>. The default destination for a data object is to be
presented to the user dependent on which interface the application is
using to the HTML parser. However, both the destination and the media
type for the data object can be changed by assigning values to the
Request structure.  The Library distinguishes between two
situations:

<OL>
<LI>If a request results in a success response from the remote server
or local file system then  the data object is sent down the <CODE>output_stream</CODE>,
which by default is going to the screen. 
<LI>A data object following a error response. In case an error message
is followed by an explanatory data object, often in HTML format, then
this object is sent down the <CODE>error_stream</CODE> instead of the
<CODE>output_stream</CODE>. This information can for example be
presented to the user in a special debug window. By default ,
information going to the <CODE>error_stream</CODE> ends in a <EM>black
hole</EM> which means that the data is ignored.
</OL>

The format of the data object can be changed to any media type
known by the Library by assigning a value to the output_format field in
the request structure. This can be used to see the source code before
the object is parsed, metainformation

<H3>Exploiting the HTTP Module</H3>

The Library is designed to conform to the HTTP specification but at
the same time to leave room for experiments with new headers etc. By
default the Library only sends the headers required to fulfill a
request depending on the method, but the application can affect the
HTTP request sent to the remote server by specifying which headers
should be included in the request. This is done using the following
bitmasks:

<DL>
<DT><CODE>GenMask</CODE></DT>
<DD>Defines all the general HTTP headers that can be a part of any
request and response</DD>
<DT><CODE>RequestMask</CODE></DT>
<DD>Defines the request headers that describes the clients (and users)
preferences for the requested data obejct</DD>
<DT><CODE>EntityMask</CODE></DT>
<DD>Defines the entity headers that describes the entity sent in either
a request (PUT and POST) or a response.</DD>
</DL>

Experimental headers can be added to any request by using the
<CODE>ExtraHeaders</CODE>. The field is included in the request as is
so it must contain the appropriate &lt;CRLF&gt; line terminators as
described by the <A HREF="../../../Protocols/">HTTP specification</A>.

<P>It is highly recommended that the application uses the available
HTTP headers when appropriate, especially the specification of natural
languages and versioning headers when using <CODE>PUT</CODE> and
<CODE>POST</CODE>.

<H3>Error Handling</H3>

The Library error handler delivers detailed messages to the
application about any error situation occured while handling a request.


<PRE><B>	MORE</B></PRE>

<H1>Managing the HyperDoc Object</H1>

<B>MORE</B>

<H1>The Access Manager</H1>

At this point most of the design issues have been addressed and the
Library it is now possible to use the Library to exchange information
between the application an the Internet. The Library provides a set of
functions that can be used to request a URI either on a remote server or
on the local file system. The access method binds the URL with a
specific protocol module as described in section
<A HREF="#access">Access Methods</A> and the stream chains defines the
data flow for incoming and outgoing data.</P>


<H3>Searching a URL</H3>
<PRE>	<B>	MORE</B></PRE>

<H3>Receiving an Entity</H3><PRE>	<B>	MORE</B></PRE>

<H3
>Sending an Entity</H3>
<PRE>	<B>	MORE</B></PRE>

<H3>Return Codes from the Access manager</H3>

The access manager has a standard set of return codes that the
application can use for diagnostics. They should only be used as
indications of the result as a more detailed description of any error
situation is registered  in the error handler. The set of codes are:</P>

<DL>

<DT><CODE>HT_LOADED</CODE></DT>
<DD>A generic success code that indicates that the request has been
fulfilled

<DT><CODE>HT_NO_DATA</CODE>
</DT>
<DD>Partly a success code, but no document has been retrieved and a
client application is encouraged to maintain the previous document view
as the current view. A <CODE>HT_NO_DATA</CODE> code might be the result
when a  telnet session is started etc.

<DT><CODE>HT_ERROR</CODE>
</DT>
<DD>An error has occured and the request could not be fulfilled

<DT><CODE>HT_RETRY</CODE>
</DT>
<DD>The remote server is temporarily unavailable and no more requests
should be issued to the server before the calendar time indicated in
<CODE>HTRequest-&gt;retry_after</CODE> field. No action is taken by the
Library to automatically retry the request, this is uniquely for the
application to decide. 

<DT><CODE>HT_WOULD_BLOCK</CODE></DT>
<DD>An I/O operation would block and the request must pause. As the
request is not yet terminated, the operation will continue at a later
time when the blocking situation has ceased  to exist.

</DL>

<H1>The Protocol Manager</H1>

<B>MORE</B>

<H1>The Format Manager</H1>

<UL>
<LI>setting up request streams
<LI>memory management
<LI>examples
</UL>

<H1>The Cache Manager</H2>

Caching is a required part of any efficient Internet access
applications as it saves bandwidth and improves access performance
significantly in almost all types of accesses.  The Library supports
two different types of cache: The memory cache and the file cache. The
two types differ in several ways which reflects their two main
purposes: The memory cache is for short term storage of graphic
objects whereas the file cache is for intermediate term storage of
data objects. Often it is desirable to have both a memory and a file
version of a cached document, so the two types do not exclude each
other. The following paragraphs explains how the two caches can be
maintained in the Library.</P>

<H3><A NAME="memcache">Memory Cache</A></H3>

The memory cache is largely managed by the application as it simply
consists of keeping the graphic objects described by the
<CODE>HyperDoc</CODE> structure in memory as the user keeps requesting
new documents. The <CODE>HyperDoc</CODE> structure is only declared in
the Library - the real definition is left to the application as it is
for the application to handle graphic objects. The Line Mode Browser
has its own definition of the <CODE>HyperDoc</CODE> structure called
<A HREF="../../../LineMode/Implementation/GridText.html"
><CODE>HText</CODE></A>. Before a request is processed over the net,
the anchor object is searched for a <CODE>HyperDoc</CODE> structure
and a new request is issued only if this is not present or the Library
explicitly has been asked to reload the document, which is described
in the section <A HREF="#reload">Short Circuiting the Cache</A></P>

As the management of the graphic object is handled by the application,
it is also for the application to handle the garbage collection of the
memory cache. The <A HREF="../../../LineMode/">Line Mode Browser</A>
has a very simple memory management of how long graphic objects stay
around in memory. It is determined by a constant in the <A
HREF="../../../LineMode/Implementation/GridText.c" >GridText</A>
module and is by default set to 5 documents. This approach can be much
more advanced and the memory garbage collection can be determined by
the size of the graphic objects, when they expire etc., but the API is
the same no matter how the garbage collector is implemented. </P>


<H3>File Cache</H3>

The file cache is intended for intermediate term storage of documents
or data objects that can not be represented by the
<CODE>HyperDoc</CODE> structure which is referenced by the
<CODE>HTAnchor</CODE> object. As the definition of the
<CODE>HyperDoc</CODE> structure is done by the application there is no
explicit rule of what graphic objects that can not be described by the
<CODE>HyperDoc</CODE>, but often it is binary objects, like images
etc.</P>

The file cache in the Library is a very simple implementation in the
sense that no intelligent garbage collection has been defined. It has
been the goal to collect experience from the file cache in the W3C
proxy server before an intelligent garbage collector is implemented in
the Library.  Currently the following functions can be used to control
the cache, which is disabled by default:</P>

<DL>
<DT><CODE>HTCache_enable()</CODE>, <CODE>HTCache_disable()</CODE>, and
<CODE>HTCache_isEnabled()</CODE>
<DD>Use these functions to enable and disable the cache

<DT><CODE>HTCache_setRoot()</CODE> and <CODE>HTCache_getRoot()</CODE>
<DD>Use these functions to set and get the value of the cache root
</DL>

An important difference between the memory cache and the file cache is
the format of the data. In the memory cache, the cached objects are
graphic objects ready to be displayed to the user. In the file cache
the data objects are stored along with their metainformation so that
important header information like Expires, Last-Modified, Language
etc.  is a part of the stored object.</P>

<H3><A NAME="reload">Mode for Cache Refresh</A></H3>

In situations where a cached document is known to be stale it is
desired to flush any existent version of a document in either the
memory cache or the file cache and perform a reload from the
authoritative server. This can for example be the case if an expires
header has been defined for the document when returned from the origin
server. Forcing a refresh from either the memory cache, the file
cache, or both can be done using the following function:

<PRE>
void HTRequest_setReload (HTRequest *request, HTReload mode);
HTReload HTRequest_reload (HTRequest *request);
</PRE>

where <CODE>HTReload</CODE> can be either of the values

<DL>
<DT>HT_ANY_VERSION
<DD>Use any version available, either from memory cache or from local
file cache

<DT>HT_MEM_REFRESH

<DD><EM>Non-authoritative</EM> update of any version stored in
memory. The new version can either come from the local file cache, a
proxy cache or the network. If the request falls through to the
network, the Library issues a conditional GET using a
<EM>If-Modified-Since</EM> header. There are two main purposes for
this mode:

<OL>
<LI>If the disk cache is private to exactly one application then a
version stored in the local disk cache does normally not differ in
time from a version in memory - they have been created at the same
time. However, in a shared cache environment, the two versions can
differ and this flag can be used to force an update to the latest
version in the file cache.
<LI>If the application wants to see the metainformation as received
from the network, then the object in the file cache provides this
information whereas the version in memory does not.
</OL>

<DT>HT_CACHE_REFRESH

<DD><EM>Authoritative</EM> update of any version stored in the local
file cache or a proxy cache. The Library issues a conditional GET
using a <EM>If-Modified-Since</EM> header and a <EM>Pragma:
no-cache</EM> to ensure that the response is authoritative.

<DT>HT_FORCE_RELOAD

<DD>Unconditinal reload from the network using the <EM>Pragma:
no-proxy</EM> directive in order to insure that the reload is passed
to any proxy server on the way to the origin server

</DL>

If the Library receives either an authoritative or non-authoritative
"304 Not Modified" response upon any of the requests above, it 

<H3>Handling Expired Documents</H3>

There are various ways of handling Expires header when met in a
history list. Either it can be ignored all together, the user can be
notified with a warning, or the document can be reloaded
automatically. The Libarry supports either way, as it should be up to
the user to decide. The default action is HT_EXPIRES_IGNORE, but other
modes are to notify the user that a document is stale without
reloading it, and to do an automatic relaod of the document. Th
functions to use are in this case:

<PRE>
void HTAccess_setExpiresMode (HTExpiresMode mode, char *  notify);
HTExpiresMode HTAccess_expiresMode ();
</PRE>

where <CODE>HTExpiresMode</CODE> can take any of the values:

<PRE>
    HT_EXPIRES_IGNORE
    HT_EXPIRES_NOTIFY
    HT_EXPIRES_AUTO
</PRE>

<H1>The Error Manager</H1>

<B>MORE</B>

<H1>The Event Manager</H1>

<B>MORE</B>

<H1>The Log Module</H1>

It is possible to log the result of a request to the Library whether
regardless of what type of application is using the Library. The
current implementation of the log manager is very simple but it is
straight forward to replace the implementation with a more
sofisticated one. The current log format is defined as follows:

<PRE>
	&lt;HOST&gt; &lt;DATE&gt; &lt;METHOD&gt; &lt;URI&gt; &lt;RESULT&gt; &lt;CONTENT LENGTH&gt;
</PRE>

where the date and time stamp can be either in local time or
GMT. Logging is turned off but the application can enable it at any
time. However, it is also for the application to disable the logging
in order to close any open file descriptors etc. The exact log API is
described in the <A HREF="../../Implementation/HTLog.html">Log
Manager</A>.

<H1>Keeping Track of History</H1>

The Library supports client applications in keeping track of which
locations the user has visited while browsing the Web. The internal
history list is implemented in the <A
HREF="../../Implementation/HTHist.html">HTHist module</A>. This module
is completely autonomous as it is not used by any other modules in the
Library so if it is not referred to in the application code then it
will not be linked into the linked application. This means that if the
application does not need recording of history then no action is
required at all.<P>

The purpose of the history module is to try not to impose any
particular history mechanism policy but instead to allow various
different history mechanisms. The basic features of the history module
are:

<UL>
<LI>The module can handle multiple history lists
<LI>The underlying data structure is a linear list structure
<LI>The module keeps a position pointer into this list
<LI>The application can refer to an element in the list by an index
</UL>

Some of the navigation steps supported by the module are "back",
"forward", and jump to a position in the list. The details of the
module is listed in the declaration part of the <A
HREF="../../Implementation/HTHist.html">HTHist module</A>.

<H1>The HTTP/MIME Parser</H1>

In version 3.1 of the Library, the HTTP header parser has been made
significantly more flexible and does support all HTTP headers included
in the <A HREF="../../../Protocols/" >HTTP/1.0 specification</A> as
defined by the latest draft plus allows management of unknown
headers. Together with the support for extra headers as described in
section <A HREF="#request">The Request Object </A> this allows
applications more easily to experiment with HTTP.  All metainformation
relevant to the actual communication between the client and the server
is stored in the request object whereas the metainformation describing
the entity body is stored in the anchor object. It is important to
note that this information can be used both when requesting a document
on a remote server and when describing an entity that is to be sent to
a remote server using a method like <CODE>PUT</CODE> or
<CODE>POST</CODE>. Some of the more special headers are: </P>

<DL>
<DT><CODE>Allow</CODE></DT>
<DD>Builds a list of allowed methods for this entity

<DT><CODE>ContentEncoding</CODE></DT>
<DD>

<DT><CODE>ContentLanguage</CODE></DT>
<DD>Builds a list of natural languages

<DT><CODE>ContentLength</CODE></DT>
<DD>This parameter is now passed

<DT><CODE>ContentType</CODE></DT>
<DD>The <CODE>ContentType</CODE> header now support the <CODE>charset</CODE>
parameter and the <CODE>level</CODE> parameter, however none of them
are used by the <A HREF="#HTML">HTML parser</A> 

<DT><CODE>Date</CODE>, <CODE>Expires</CODE>, <CODE>RetryAfter</CODE>,
 and <CODE>LastModified</CODE></DT>
<DD>All date and time headers are parsed understanding the following
formats: RFC 1123, RFC 850, ANSI C's asctime(), and delta time. The
latter is a non-negative integer indicating seconds after the message
was received.  Note, that it is <EM>always</EM> for the application to
issue a new request as a function of any of the date and time headers..

<DT><CODE>DerivedFrom, Version</CODE></DT>
<DD>For handling version control when managing collaborative works
using HTTP.

<DT>Unknown Headers</DT>
<DD>Unknown headers are put into a separate list which the application
can accesss. 
 
</DL>  

<H1>The HTML Parser</H1>

The HTML parser has three different levels of APIs in order to make
the implementation as flexible as possible.  Depending on which API is
used by the application, the output can be a stream, a structured stream
or a set of callback functions as indicated in the figure below:

<P><IMG SRC="../Guide/Interfaces.gif" ALT="HTMLParser"><P>

<DL>

<DT>SGML Stream Interface

<DD>This interface provides the most basic API consisting of the
output from a stream without any form for structure imposed on the
data. The internal <A HREF="../../Implementation/SGML.html">SGML
parser</A> parses the data sequence, identifies SGML markup tags, and
passes the information on the the <A
HREF="../../Implementation/HTML.html">HTML parser</A>. However, if the
application has its own SGML parser and HTML parser, the internal
parsers can be disabled by removing the internal HTML converter called
<CODE>HTMLPresent()</CODE> used to present a graphic object on the
screen from both the global and the local list of converters and
presenters.

<DT>HTML Structured Stream Interface

<DD>If the application has its own HTML parser that understands the
structured output from the internal SGML parser then the second API
can be used. The current HTML parser in the Library is very basic and
does not understand many of the new features in HTML 2 and 3.

<DT>HText Call Back Interface

<DD>The last API can be in case the application prefers to use the
internal HTML parser and only wants to provide a platform dependent
definition of the callback functions defined in the <A
HREF="../../Implementation/HText.html" >HText module</A>.  Now, the
parsing is all done internally in the Library and the application is
only called with segments of fully parsed HTML. The callback functions
are all defined as prototypes in the <A
HREF="../../Implementation/HText.html" >HText module</A> but the
client must provide the actual code that defines the presentation
method used for a specific HTML tag.

</DL>

Due to the limited functionality of the internal HTML parsing module,
many applications have chosen to implement their own HTML
parser. Therefore many regard the HTML parser module as being an
<EM>application specific module</EM> instead of a <EM>dynamic
module</EM>. This will be alleviated in the next version of the
Library, which hopefully will ease the use of the internal HTML
parser. The current parser can be overriding as described in section
<A HREF="#override">Application Specific Modules</A>.

<H1>Application Specific Modules</H1>

As explained in the section <A HREF="#start">Get Started</A>, the
<EM>application specific modules</EM> are often implemented to support
a simple interface as provided by the Line Mode Browser. However,
these and other modules can be overridden by more complex
applications, for example using a GUI window manager. A Library module
is overriding by redefining all external references (normally declared
in the include file) by new definitions in an application module. By
doing this the linker takes the new definition of the module instead
of the Library version and links it into the final executable file.
The declaration (the include file) stays the same, but the definition
has changed. The application module does not need to be called the
same as the Library module, only the external references.  External
references are both global variables and public functions visible to
other modules. As an example, the following module:</P>

<PRE>	/* Library.c */
	char GlobalFlag;
	int GlobalFunction(void)
	{
		/* Library Implementation */
	}
</PRE>

 with the declaration file:</P>

<PRE>	/* Library.h */
	extern char GlobalFlag;
	extern int GlobalFunction(void);
</PRE>

 can get a new definition module</P>

<PRE>	/* Application.c */
	char GlobalFlag;
	int GlobalFunction(void)
	{
		/* Application Implementation */
	}
</PRE>

which will then be linked into the executable program. The
following paragraphs describe the </P>


<H3><A NAME="history">Keeping
Track of History</A></H3>

The Library has a simple method to keep
track of which locations the user has visited while browsing the Web.
The internal history list is implemented in the <A HREF="../../Implementation/HTHist.html"
>HTHist module</A>, and is based on a linear list of visited documents
with a destructive backtrack. The <A HREF="../../Implementation/HTHist.html"
>HTHist module</A> is completely autonomous as it is not used by any
other modules in the Library so if it is not referred to in the
application code then it will not be linked into the linked application.
This means that if the application does not need recording of history
then no action is required at all. </P>


<H3><A NAME="alert">User
Prompts and Confirmations</A></H3>

The <A HREF="../../Implementation/HTAlert.html"
>HTAlert module</A> contains the functionality for prompting the user
for confirmations, questions, input etc. and to pass information like
warnings, error etc. back to the user. The internal definition is based
on highly portable code using ANSI C functions for input and output so
it is required to override this module when implementing a GUI client.
The functions are divided into two groups:</P>

<UL>
<LI>A user interactive part requiring an action (confirmation etc) by
the user.
<LI>A part for sending messages to the user requiring no explicit
confirmation
</UL>

The main difference from the history module is that this module
is always linked into the application as it is used by other modules in
the Library. Hence the definition of the module must be provided either
by the internal or an external definition. The internal implementation
uses the global variable <EM>HTInteractive</EM> to define whether any
interaction should be directed to the user or not. If no interaction is
desired, like for example when running an application in batch mode,
then this flag prevents the application to prompt the user for any
confirmations. </P>


<H3>The External event loop</H3>

In case the
application has its own event loop, and wants to use the Library in <B>Passive
mode</B> then the internal <A HREF="../../Implementation/HTEvent.html">HTEvent
module</A> must be replaced by a new definition in the application.
</P>

<PRE>	<B>	MORE</B></PRE>

<H3>The Binding Module</H3>

As
mentioned in the section <A HREF="#bind">Bindings to the local file
system</A> the bindings between a data object and its content types,
languages etc. is by default done using file suffixes. However, this can
be replaces by, for example a database interface by overriding the <A HREF="../../Implementation/HTBind.html"
>HTBind module</A>.</P>

<H1>Global Flags</H1>

The global flags consist of global variables, environment variables,
and preprocessor defines. Some have already been introduced in the
previous sections but this section gives a more complete listing.

<H3>Global Variables</H3>

Global variables have until recently been in widespread use throughout
the Library but as this often conflicts with a multithreaded
environment, many global variables have been replaced with thread-safe
representations. However, many modules do still contain state
independent global variables defining display options, global
time-outs, trace options etc. Typical examples are the module to
generate <A HREF="../../Implementation/HTDirBrw.html">directory
listings</A> for HTTP, FTP, and local file access to directories and
the <A HREF="../../Implementation/HTError.html" >error handling
module</A>.

Only four specific global variables are to be mentioned in this paper,
The first two must be defined in the application before linking with
the library, and they <EM>must</EM> be assigned values with specific
semantics.

<DL>

<DT><CODE>HTAppName</CODE>

<DD>A string defining the name of the application. This value is used
in the <EM>User-Agent</EM> field in the <A
HREF="../../../Protocols/">HTTP Protocol</A> and it must obey the
semantics for this field.

<DT><CODE>HTAppVersion</CODE>

<DD>A string defining the version of the application. The value is also
used in the <CODE>User-Agent</CODE> field and must obey the general
semantics for this field. 

<DT><CODE>HTSecure</CODE>
<DD>If this flag is enabled then the application has no access to the
local file system.  This allows applications to be used as a shell for
remote logins, for example using telnet. the default value is <EM>OFF</EM>

<DT><CODE>HTImProxy</CODE>
<DD>A proxy server must have a socket as the default destination for
incoming data in order to forward data either to the proxy client or to
the remote server. If this flag is set, then  the default behavior of
sending data to the user is diabled. The default value is <EM>OFF</EM>.

</DL>

<H3>Environment Variables</H3>

Apart from the environment
variables for setting up a proxy server or a gateway described in
section <A HREF="Methods.html">Access Methods</A>, the Library supports only
two other environment variables:
</P>

<DL>
<DT><CODE>WWW_HOME</CODE>
<DD>This variable is used by the help function
<CODE>HTHomeAnchor()</CODE> to find the address of the default document
to load when a client application is started. If no <CODE>WWW_HOME</CODE>
variable has been specified at run time, by default, the Library returns
<B>http://www.w3.org/</B>.
 
<DT><CODE>USERNAME</CODE>, <CODE>LOGNAME</CODE>, <CODE>USER</CODE>
<DD>These are the variables that are searched when looking for the user
name of the current user. They are somewhat platform dependent as the
<CODE>USERNAME</CODE> is for Windows NT, and the others are for Unix
with <CODE>LOGNAME</CODE> as having highest priority.

</DL>

<H3>Preprocessor Defines</H3>

Most of the preprocessor defines
in the Library are platform dependent that are determined as a result of
the <EM>BUILD script</EM>. However, there are some few defines that on
a platform independent basis can change the default behavior of the
Library.</P>

<DL>
<DT><CODE>HT_REENTRANT</CODE>

<DD>This boolean define should be enabled if the reentrant versions
("*_r") of the system calls should be used. The name of these system
calls are currently "*_r", for example <CODE>strtok_r</CODE>. The
default value is <EM>OFF</EM>.

<DT><CODE>HT_SHARED_DISK_CACHE</CODE>

<DD>If the cache can be shared between several clients this will have
an effect on the way, update of a document will be done. The default
cache implementation of the cache manager does not support this so the
default value is NOT defined.

<DT><CODE>HT_DIRECT_WAIS</CODE>

<DD>This boolean define is enabled by the <EM>Makefile.include</EM>
file as described in section <A HREF="Methods.html">Access Methods</A>. The
default value is <EM>OFF</EM>.

<DT><CODE>HT_DEFAULT_WAIS_GATEWAY</CODE>

<DD>A constant string value which WAIS gateway to contact if
<CODE>HT_DIRECT_WAIS</CODE> is not defined and no gateway has been
defined using environment variables

<DT><CODE>HT_FTP_NO_PORT</CODE>

<DD>The FTP module can handle both <CODE>PASV</CODE> and
<CODE>PORT</CODE> when requesting a document from a FTP server. If the
application is a proxy server running on top of a firewall machine
then <CODE>PORT</CODE> is normally not allowed as a firewall does not
accept incoming connections on arbitrary ports. This define will
disable the use of <CODE>PORT</CODE>. The default value is to
<EM>use</EM> <CODE>PORT</CODE> if <CODE>PASV</CODE> fails.

<DT><CODE>HT_NO_INIT</CODE>

<DD>If this flag is defined then the Library will not initialize any
access methods or media types in the <CODE>HTLibInit()</CODE>
function, but leaves this to the application. By default, the flag is
<EM>not</EM> defined.

<DT><CODE>WWWLIB_SIG</CODE>

<DD>The Library has a very small set of signal handlers whose action
most often are simply to ignore the signals. However, due to a bug in
the TCP kernel on Solaris and other SVR4 platforms returning a
SIG_PIPE signal, some kind of handling is required on these platforms,
and the signal handling is enabled by default on these platforms.

<DT><CODE>HT_TMP_ROOT</CODE>

<DD>The default destination for temporary files if no other
destination has been given by the application. Temporary files include
files created for external presenters etc. The default value is
<CODE>/tmp</CODE> which obviously is not suited for large amount of
data.

<DT><CODE>HT_CACHE_ROOT</CODE>

<DD>If the cache is enabled and no cache root directory has been
specified then use this as the location. The default value is again
<CODE>/tmp</CODE>.

<DT><CODE>HT_NO_RULES</CODE>

<DD>If this flag is enabled then no configuration or rule file is
searched for map rules when handling a request even if a rule file has
been specified by the application. The default value is <EM>OFF</EM>

<DT><CODE>HT_NO_PROXY</CODE>

<DD>If no environment variables are to be searched for gateways or
proxies for a request. The default value is <EM>OFF</EM>

</DL>

<P>
<HR>
<ADDRESS>Henrik Frystyk, <A HREF="mailto:libwww@w3.org">libwww@w3.org</A>, July 1995</ADDRESS>
</BODY>
</HTML> 
