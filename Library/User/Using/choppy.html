<HTML>
<HEAD>
<TITLE>Using the W3C Reference Library</TITLE>
<!-- Changed by: Henrik Frystyk Nielsen, 12-Oct-1995 -->
</HEAD>  
<BODY>

<A HREF="../../../"><IMG SRC="../../../Icons/WWW/WWW48x.gif" ALT="WWW"></A>
<A HREF="../../"><IMG SRC="../../../Icons/WWW/Lib48x.gif" ALT="Lib"></A>
<IMG SRC="../../../Icons/WWW/guide48x.gif" ALT="Using">

<H1>Using the W3C Reference Library</H1>

<IMG SRC="../../../Icons/WWW/construction.gif" ALT="WIP"> This paper
is still under construction. Comments are welcome at <A
HREF="mailto:libwww@w3.org">libwww@w3.org</A></P>

This is the user guide documentation describing the W3C Reference
library. It concentrates on the API and how the application programmer
can use the Library. It also describes who is responsible for memory
management and when things can be initialized etc. It is basically a
filteret version of the <A HREF="../Guide/">Internals</A> document
where only the "public" functions are described. This document is the
second of three documents that each describes different aspects of the
Library:

<DL>

<DT><A HREF="../Architecture/"><IMG ALT="Architecture" SRC="../../../Icons/WWW/design48x.gif"></A> <B>The Architecture</B>

<DD>The current document is the first in the series and it describes
the architecture of the Library without referring directly to the code
itself. This is the "designer view" where bugs are a unknown
phenomenon.

<DT><A HREF="./"><IMG SRC="../../../Icons/WWW/guide48x.gif" ALT="Using"></A> <B>The User's Guide</B>

<DD>The second document introduces the "official" API of the
Library. This document represents the "User's view" and should be
sufficient to use the Library without being aware of what's going on
underneeth the interface. It is also the API that is least exposed to
changes. The description contains a set of examples.

<DT><A HREF="../Guide/"><IMG ALT="Internals" SRC="../../../Icons/WWW/internals48x.gif"></A> <B>The Internals and Programmer's Guide</B>

<DD>The last document in the serie presents all modules in the Library
regardles if they are part of the API described in the User's Guide or
not. This is also known as the "hacker's view" of the Library.

</UL>

<IMG ALIGN=BOTTOM SRC="../../../Icons/32x32/caution.gif" ALT="NOTE">
Each part of the documentation is also available as <A
HREF="choppy.html"><B>one big HTML file</B></A> intended for
printout. As a result, the relative links in this document do not
work!<P>


<H2>Table of Contents</H2> 
<OL>
<LI><A HREF="Startup.html">Getting Started</A>
<LI><A HREF="Prefs.html">Setting Up Preferences for Language, Charset etc.</A>
<LI><A HREF="Bind.html">Make Bindings to the local File system</A>
<LI><A HREF="Methods.html">Registering Access Schemes</A>
<LI><A HREF="Proxy.html">Registering Proxy Servers and Gateways</A> <P>

<LI><A HREF="Anchors.html">Anchor Objects</A>
<LI><A HREF="Request.html">Request Objects</A>
<LI><A HREF="HyperDoc.html">HyperDoc Objects</A><P>

<LI><A HREF="Access.html">The Access Manager</A>
<LI><A HREF="Protocol.html">The Protocol Manager</A>
<LI><A HREF="Streams.html">The Format Manager</A>
<LI><A HREF="Cache.html">The Cache Manager</A>
<LI><A HREF="Error.html">The Error Cache</A>
<LI><A HREF="Event.html">The Event Manager</A><P>

<LI><A HREF="Logging.html">The Log Module</A>
<LI><A HREF="History.html">The History Module</A>
<LI><A HREF="MIME.html">The HTTP/MIME Parser</A>
<LI><A HREF="HTML.html">Presentation Modules</A>
<LI><A HREF="Override.html">Application Specific Modules</A>
<LI><A HREF="Flags.html">Global Flags and special Modes</A>
</OL>

<H1>Getting Started</H1>

The Library distribution package can be obtained from the <A
HREF="../../">Library status page</A> and it includes all source files
and some <A HREF="../../../README.html">README</A> files describing
what the package contains. There is also an online "<A
HREF="../Installation.html">Installation Guide</A>" explaining how to
unpack and compile the Library. As new versions of the Library are
released frequently, it is recommended that you verify that the
version is up to date by looking into the "Version.Make" file in the
"Implementation" directory of the Library and compare it with the
information given at the <A HREF="../../">Library status page</A>.<P>

From version 3.0, the include file "<A
HREF="../../Implementation/WWWLib.html">WWWLib.h</A>" is the only
include file which is required in order to use the Library.  This file
contains all the functionality that is publicly available, but as the
architecture is currently very exposed, this includes most of the
modules in the Library itself.  Apart from this, only two functions
are necessary in order to initialize and cleanup the Library
respectively:

<DL>

<DT><CODE>BOOL HTLibInit()</CODE>

<DD>This function initializes memory, file descriptors, interrupt
handlers etc. By default it also calls initialization functions for
all the dynamic modules in the Library. The dynamic modules are
described in "<A HREF="../Architecture/DesignModel.html">Libwww
Architecture</A>". A major part of the User's Guide is to describe how
the Library can be configured, both at run time and at compile time,
and the dynamic modules are an important part of the Library
configuration.

<DT><CODE>BOOL HTLibTerminate()</CODE>

<DD>Cleans up the memory and closes open file descriptors.

</DL>

It is essential that <CODE>HTLibInit()</CODE> is the first call to the
Library and <CODE>HTLibTerminate()</CODE> is the last as the behavior
otherwise is undefined. As an example, a minimal application will look
like this:

<PRE>
	#include &lt;WWWLib.h>
	/* Other initializations */

	int main()
	{
		HTLibInit();

		/* Application stuff */

		HTLibTerminate();
		return 0;
	}
</PRE>

<H1>Request Preferences</H1>

This section describes how to setup preferences for the representation
of a data object when requesting it from the network. The
representation of a data object is closely related to the format
negotiation in the <A HREF="../../../Protocols/">HTTP protocol</A> as
each dimension can be expressed as an "accept-*" header in an HTTP
request. The Library supports the following dimensions:

<UL>
<LI>The preferred natural langauge of the data object
<LI>The media type in which a data object should be rendered
<LI>The preferred content encodings (or supported)
<LI>The preferred character set
</UL>

Preferences can be registered in two ways: As a <EM>global</EM> list
which applies to all requests and a <EM>local</EM> list which is bound
to a specific request. The global and local lists are simply added
when the preferences for a request are converted to a set of
"accept-*" headers. There is currently no means or overriding global
preferences with the local preferences.</P>

It is important to note that <EM>none</EM> of the preferences are
enabled automatically by the Library - it is for the application to
specify as the preferences can change from request to
request. However, the Library has a set of default initialization
functions that make it easy for the application to set the preferences
that are directly supported by the Library. These are all located in
the <A HREF="../../Implementation/HTInit.html">HTInit module</A> and
can be modified to suit a particular application.</P>

<H3>Natural Languages</H3>

The user's preferences of natural languages can as converters and
presenters be registered both globally for all requests and locally
for a single request. The global list is called
<CODE>HTLanguages</CODE>, and the local list is a part of the <A
HREF="../../Implementation/HTAccess.html#z1">HTRequest structure
</A>as described in section <A HREF="#request">Issue an Request</A>
but in contrast to the converters there is no initialization function
in the <A HREF="../../Implementation/HTInit.html">HTInit module</A>.
Preferences for natural languages can be added individually to both
the local and global list using the functions:</P>

<PRE>
	HTAcceptLanguage()
</PRE>

<H3>Setting up the Media Types</H3>

The media types are handled by a set of converters and presenters. A
converter is a stream that can convert the rendition of a data object
from one format to another. A presenter is a stream that calls an
external program, for example a post script viewer or an audio program
for presenting the data obejct. Converters and presenters are special in that they both describe the preferred set of media types to be requested in a HTTP request and how a 


Both converters and presenters take
part in the stream stack algorithm that finds the best conversion of
the media type of a data object. The difference is that presenters
depend on external viewers for the presentation of the graphic object
whereas converters use internal modules in the Library and they do not
necessarily have to present the graphic object to the user. The
Library has two initialization functions which are defined in the <A
HREF="../../Implementation/HTInit.html" >HTInit module</A> as
described in the section <A HREF="#start">Get Started</A> The two
functions for setting up a list of default converters and presenters
respectively are: </P>

<PRE>
	void HTConverterInit(HTList *list);
	void HTPresenterInit(HTList *list);
</PRE>

Converters and presenters can be registered both globally for all
requests and locally for a single request. The global list is called
<CODE>HTConversions</CODE>, and the local list is a part of the <A
HREF="../../Implementation/HTAccess.html#z1">HTRequest structure
</A>as described in section <A HREF="#request">Issue an Request</A>.
This can be used to set up a global set of basic converters and a
local set of additional converters or presenters for a single
request. In the Line Mode Browser this is used to distinguish between
running in interactive mode or non-interactive mode. In the latter
mode, no external presenters are allowed, whereas this is a normal
part of the interactive mode. Hence the global set is the list of
converters and the local list is the list of presenters if running in
interactive mode:</P>

<PRE>
	HTConverterInit(HTConversions);			/* Set up global list */
	if (HTInteractive)
		HTPresenterInit(request->conversions);	/* Local list */
</PRE>

Converters and presenters can both be added individually to both the
local and global list using the functions:</P>

<PRE>
	HTSetPresentation()
	HTSetConversion()
</PRE> 

The initialization functions are in fact only a compiled list of calls
to these function.</P>

<H3>Encodings</H3>

The set of encoding and decoding streams are in the same category as
converters and presenters, but the Library does currently not provide
any encoders or decoders. Therefore there is no initialization
function in the <A HREF="../../Implementation/HTInit.html" >HTInit
module</A>. However, as for converters and presenters encodings and
decodings capabilities can be registered both globally for all
requests and locally for a single request. The global list is called
<CODE>HTEncodings</CODE>, and the local list is a part of the <A
HREF="../../Implementation/HTAccess.html#z1">HTRequest structure</A>
as described in section <A HREF="#request">Issue an Request</A>.
Encoders can be added individually to both the local and global list
using the functions:

<PRE>
	HTAcceptEncoding()</PRE>

<H3>Charsets</H3>

The user's preferences of chracter sets (a parameter on the content
type) can as converters and presenters be registered both globally for
all requests and locally for a single request. The global list is
called <CODE>HTCharsets</CODE>, and the local list is a part of the <A
HREF="../../Implementation/HTAccess.html#z1">HTRequest structure
</A>as described in section <A HREF="#request">Issue an
Request</A>. As for the list of natural languages there is no
initialization function in the <A
HREF="../../Implementation/HTInit.html">HTInit module</A>.
Preferences for charsets can be added individually to both the local
and global list using the functions:</P>

<PRE>
	void HTAcceptCharset(HTList *list, const char *charset, double quality);
</PRE>

<H1>Bindings to the local File system</H1>

Client applications have access to the local filesystem using
<EM>file</EM> URLs and server applications has inherently a close
connection to the local file system from which it is serving files to
the requesting parties. The binding betweeen a file and its
representation internally in the Library, that is the content-type,
natural language, and encoding is maintained by the <A
HREF="../../Implementation/HTBind.html">HTBind module</A>. The current
implementation of this module bases the binding on file suffixes, but
the module is separated so that other kind of bindings can be
implemented, for example using a database. The set of suffix
delimiters is normally a function of the current platform, but can at
any time be modified, so that for example the characters ".", "_", and
"+" can be defined as delimiters. </P>


As for the converters and presenters, the Library has a default set of
bindings between media types and file name extensions but the
difference is that the bindings are initialized at start up time in
the <CODE>HTLibInit()</CODE> function, and hence does not have to be
done explicitly by the application.  However, new bindings can be set
up using the methods:</P>

<PRE>
	HTBind_setType()
	HTBind_setEncoding()
	HTBind_setLanguage()
</PRE>

If the Library is to handle a file that is not described by
the binding rules, it reads the first part of the data object and try
and guess the media type. This is an internal operation in the Library
and does not require any interaction with the application.</P>

<H1><A NAME="methods">Enabling Access Methods</A></H1>

The Library handles a wide set of Internet Protocols as well as access
to the local file system. The current set of access methods supported
are: HTTP, FTP, Gopher, telnet, rlogin, NNTP and WAIS. All protocol
modules are dynamic modules and each module can be dynamically bound
to an access scheme as described in section <A HREF="#arc"
>Architectural Overview</A>. As an example, the URL:

<PRE>
	http://www.w3.org/
</PRE>

has the access scheme <EM>http</EM> and can be bound to the
<A HREF="../../Implementation/HTTP.html">HTTP module</A>. The binding
between a protocol module and an access method is by default done at
start up time in the <CODE>HTLibInit()</CODE> where the Library enables
all the access schemes that it provides services for. The application
can change the default behavior by providing its own initialization of
the binding between protocol modules and access methods. This can be
done in order to make applications with a limited set of Internet access
methods available or to add new protocol modules to the Library. There
are two ways of doing this:

<UL>

<LI>Disabling any initialization of the protocol modules in the
<CODE>HTLibInit()</CODE> function by using the <CODE>HT_NO_INIT</CODE>
preprocessor define as described in <A HREF="Flags.html">Global Flags</A>

<LI>Overriding the <A HREF="../../Implementation/HTInit.html">HTInit
module</A> by providing a new definition as described in <A
HREF="#override">Application Specific Modules</A>

</UL>

A single protocol module can be initialized using the function</P>

<PRE>
	HTRegisterProtocol()
</PRE>

One special case is the support for access to <A
HREF="../../../../Products/WAIS/">WAIS</A> databases. If native
support for access to a WAIS database is desired, the application must
be linked with a <A HREF="http://www.cnidr.org/" >WAIS library</A> in
which case the <A HREF="../../Implementation/HTWAIS.c"> HTWAIS</A>
module will be compiled into the Library as the interface between the
W3C Reference Library and the WAIS library. This can be done by
enabling the following lines in the <A
HREF="../Platform/Porting.html"> <EM>Makefile.include</EM></A> which
is the platform specific part of the <EM>Makefile</EM> created by the
<EM>BUILD</EM> script:

<PRE>
	WAIS = ../../../freeWAIS-0.3
	WAISLIB =  $(WAIS)/bin/client.a $(WAIS)/bin/wais.a
	MATHLIB = -lm
	WAISINC = -I$(WAIS)/ir
	WAISCFLAGS = -DDIRECT_WAIS
	HTWAIS = $(WTMP)/Library/$(WWW_MACH)/HTWAIS.o
</PRE>

It is important that the whole Library is rebuilt when doing this. In
case direct WAIS support is not present, the Library looks for a <A
HREF="../../../Gateways/WAISGate.html">WAIS gateway</A> in order to
handle the request and if no WAIS gateway is specified, the default
destination is defined as <A
HREF="wais://www.w3.org:8001/">wais://www.w3.org:8001/</A> where a
WAIS gateway is accepting connections.


<H1>Registering Proxy Servers and Gateways</H1>

An application can indirectly support an access method by redirecting
the request to either a proxy or a gateway. The difference between a
proxy server and a gateway is not important here as it does not affect
the application using the Library and the redirection is normally
transparent to the user. The Library supports both proxies and
gateways through the <A HREF="../../Implementation/HTProxy.html"
>HTProxy module</A> and all requests can be redirected to a proxy or a
gateway, even requests on the local file system. Of course, the
Library can also be used in proxy or gateway applications which in
terms can use other proxies or gateways so that a single request can
be passed through a series of intermediate agents.<P>

The set of public function to registere a gateway or a proxy are as
follows:

<PRE>
	BOOL HTProxy_setProxy(const char *access,const char *proxy);
	BOOL HTProxy_setNoProxy(const char *host, CONST char *access, unsigned port);
	BOOL HTProxy_setGateway(const char *access, const char *gate);
</PRE>

The <EM>no_proxy</EM> can be used to avoid contactinga proxy server
for a particular host name or domain name. The access method and port
number is optional. The behavior of the Library can be modified using
the preprocessor defines <CODE>HT_NO_RULES</CODE> and
<CODE>HT_NO_PROXY</CODE> as explained in section <A
HREF="#flags">Global Flags</A>

<H2>Using Environment Variables</H2>

Version 3.1 is the first version of the Library where proxies ans
gateways are not handled directly via environment variables, and for
backwards compatibility, there is a function in the <A
HREF="../../Implementation/HTProxy.html">HTProxy module</A> that reads
the environment variables:

<PRE>
	HTProxy_getEnvVar()
</PRE>

The format of the environmanet variables is as follows:

<DL>

<DT><CODE>WWW_&lt;access&gt;_GATEWAY</CODE>

<DD>Definition of a gateway. Note that a WAIS gateway can be defined
this way to change the default gateway at <A
HREF="wais://www.w3.org:8001/"> wais://www.w3.org:8001/</A>.

<DT><CODE>&lt;access&gt;_proxy</CODE>

<DD>Definition of a proxy server

<DT><CODE>no_proxy</CODE>

<DD>This is a comma separated list of remote servers where a proxy
server should <EM>not</EM> be consulted for handling the request. An
example is

<PRE>
	no_proxy="cern.ch,ncsa.uiuc.edu,some.host:8080"
	export no_proxy
</PRE>

</DL>

<CODE>&lt;access&gt;</CODE> is the specific access scheme and it is
case sensitive as access schemes in URIs are case sensitive. Proxy
servers have precedence over gateways, so if both a proxy server and a
gateway has been defined for a specific access scheme, the proxy
server is selected to handle the request.<P>

It is important to note that the usage of proxy servers or gateways is
an extension to the binding between an access scheme and a protocol
module. An application can be set up to redirect all URLs with a
specific access scheme without knowing about the semantics of this
access scheme or how to access the information directly. That way,
powerful client applications can be built having direct support for,
for example, HTTP only.


<H1>Using Anchors</H1>

<UL>
<LI>what do they represent
<LI>where and when to use
<LI>How to create and handle
<LI>relations between links
<LI>memory management
</UL>


<H1>The Request Object</H1>

The request manager consists of two parts: a public part and a private
part. The public part contains all the information needed to define a
request the parameters to be used when requesting a resource from the
network or local file system. When a request is handled, all kinds of
things about it need to be passed along together with a request.  <P>

<H2>Request a resource</H2>

This is an internal routine, which has an address AND a matching
anchor.  (The public routines are called with one OR the other.)

<PRE>
extern BOOL HTLoad (HTRequest * request, HTPriority priority, BOOL recursive);
</PRE>

<H2>Request Terminate Call Back Function</H2>

This function is registered at startup time by HTLibInit() in order to
probably terminate a request to the Library. The application can
register addtional call back functions in the same manner:

<PRE>
extern HTNetCallBack HTLoad_terminate;
</PRE>

<H2>Creation and Deletion Methods</H2>

The request object is intended to live as long as the request is still
active, but can be deleted as soon as it has terminatedk, for example
in one of the request termination callback functions as described in
the <A HREF="../../Implementation/HTNet.html">Net Manager</A>. Only the anchor object stays
around after the request itself is terminated.

<H3>Create new Object</H3>

Creates a new request object with a default set of options -- in most
cases it will need some information added which can be done using the
methods in this module, but it will work as is for a simple request.

<PRE>
extern HTRequest * HTRequest_new (void);
</PRE>

<H3>Delete Object</H3>

This function deletes the object and cleans up the memory.

<PRE>
extern void HTRequest_delete (HTRequest * request);
</PRE>

<H2>Bind an Anchor to a Request Object</H2>

Every request object has an anchor associated with it. The anchor
normally lives until the application terminates but a request object
only lives as long as the request is being serviced.

<PRE>
extern void HTRequest_setAnchor (HTRequest *request, HTAnchor *anchor);
extern HTParentAnchor * HTRequest_anchor (HTRequest *request);
</PRE>

<H2>Set the Method</H2>

The Method is the operation to be executed on the requested
object. The default set if the set of operations defined by the HTTP
protocol, that is "GET", "HEAD", "PUT", "POST", "LINK", "UNLINK", and
"DELETE" but many of these can be used in other protocols as well. The
important thing is to think of the requested element as an object on
which you want to perform an operation. Then it is for the specific
protocol implementation to try and carry this operation out. However,
not all operations can be implemented (or make sense) in all
protocols. <P>

Methods are handled by the <A HREF="../../Implementation/HTMethod.html">Method Module</A>,
and the default value is "GET".

<PRE>
extern void HTRequest_setMethod (HTRequest *request, HTMethod method);
extern HTMethod HTRequest_method (HTRequest *request);
</PRE>

<H2>Update, Reload, or Refresh a Document</H2>

The Library has two concepts of caching: in memory and on file. When
loading a document, this flag can be set in order to define who can
give a response to the request. <EM>IMS</EM> means that a
"If-Modified-Since" Header is used in a HTTP request.

<PRE>
typedef enum _HTReload {
    HT_ANY_VERSION	= 0x0,		/* Use any version available */
    HT_MEM_REFRESH	= 0x1,		/* Reload from file cache or network */
    HT_CACHE_REFRESH	= 0x2,		/* Update from network with IMS */
    HT_FORCE_RELOAD	= 0x4		/* Update from network with no-cache */
} HTReload;

extern void HTRequest_setReloadMode (HTRequest *request, HTReload mode);
extern HTReload HTRequest_reloadMode (HTRequest *request);
</PRE>

<H2>Max number of Retrys for a Down Load</H2>

Automatic reload can happen in two situations:

<UL>
<LI>The server sends a redirection response
<LI>The document has expired
</UL>

In order to avoid the Library going into an infinite loop, it is
necessary to keep track of the number of automatic reloads. Loops can
occur if the server has a reload to the same document or if the server
sends back a Expires header which has already expired. The default
maximum number of automatic reloads is 6.

<PRE>
extern BOOL HTRequest_setMaxRetry (int newmax);
extern int  HTRequest_maxRetry (void);
extern BOOL HTRequest_retry (HTRequest *request);
</PRE>

<H2>Retry Request After</H2>

Some services, for example HTTP, can in case they are unavailable at
the time the request is issued send back a time and date stamp to the
client telling when they are expected to back online. In case a
request results in a HT_RETRY status, the application can use any time
indicated in this field to retry the request at a later time. The
Library does not initiate any request on its own - it's for the
application to do. The time returned by this function is in calendar
time or -1 if not available.

<PRE>
extern time_t HTRequest_retryTime (HTRequest * request);
</PRE>

<H2>Accept Headers</H2>

The Accept family of headers is an important part of HTTP handling the
format negotiation. The Library supports both a global set of accept
headers that are used in <EM>all</EM> HTTP requests and a local set of
accept headers that are used in specific requests only. The global
ones are defined in the <A HREF="../../Implementation/HTFormat.html">Format
Manager</A>.  <P>

Each request can have its local set of accept headers that either are
added to the global set or replaces the global set of accept
headers. Non of the headers <EM>have</EM> to be set. If the global set
is sufficient for all requests then this us perfectly fine. If the
parameter "override" is set then only local accept headers are used,
else <EM>both</EM> local and global headers are used.

<H3>Content Types</H3>

Th <EM>local</EM> list of specific conversions which the format
manager can do in order to fulfill the request.  It typically points
to a list set up on initialisation time for example by <A
HREF="../../Implementation/HTInit.html">HTInit()</A>. There is also a <A
HREF="../../Implementation/HTFormat.html#z17"><EM>global</EM></A> list of conversions which
contains a generic set of possible conversions.

<PRE>
extern void HTRequest_setFormat	(HTRequest *request, HTList *type, BOOL override);
extern HTList * HTRequest_format (HTRequest *request);
</PRE>

<H3>Content Encodings</H3>

The list of encodings acceptable in the output stream.

<PRE>
extern void HTRequest_setEncoding (HTRequest *request, HTList *enc, BOOL override);
extern HTList * HTRequest_encoding (HTRequest *request);
</PRE>

<H3>Content-Languages</H3>

The list of (human) language values acceptable in the response. The default
is all languages.

<PRE>
extern void HTRequest_setLanguage (HTRequest *request, HTList *lang, BOOL override);
extern HTList * HTRequest_language (HTRequest *request);
</PRE>

<H3>Charset</H3>

The list of charsets accepted by the application

<PRE>
extern void HTRequest_setCharset (HTRequest *request, HTList *charset, BOOL override);
extern HTList * HTRequest_charset (HTRequest *request);
</PRE>

<H2>Handling Metainformation (RFC822 Headers)</H2>

The Library supports a large set of headers that can be sent along
with a request (or a response for that matter). All headers can be
either disabled or enabled using bit flags that are defined in the
following.

<H3><A NAME="gnhd">General HTTP Header Mask</A></H3>

There are a few header fields which have general applicability for
both request and response mesages, but which do not apply to the
communication parties or theentity being transferred. This mask
enables and disables these headers. If the bit is not turned on they
are not sent. All headers are optional and the default value is <EM>NO
GENERAL HEADERS</EM>

<PRE>
typedef enum _HTGnHd {
    HT_DATE		= 0x1,
    HT_FORWARDED	= 0x2,
    HT_MESSAGE_ID	= 0x4,
    HT_MIME		= 0x8,
    HT_NO_CACHE		= 0x10					   /* Pragma */
} HTGnHd;

#define DEFAULT_GENERAL_HEADERS		0

extern void HTRequest_setGnHd (HTRequest *request, HTGnHd gnhd);
extern void HTRequest_addGnHd (HTRequest *request, HTGnHd gnhd);
extern HTGnHd HTRequest_gnHd (HTRequest *request);
</PRE>

<H3><A NAME="rqhd">Request Headers</A></H3>

The request header fields allow the client to pass additional
information about the request (and about the client itself) to the
server. All headers are optional but the default value is all request
headers if present <EM>except</EM> <CODE>From</CODE> and
<CODE>Pragma</CODE>.

<PRE>
typedef enum _HTRqHd {
    HT_ACCEPT_TYPE	= 0x1,
    HT_ACCEPT_CHAR	= 0x2,
    HT_ACCEPT_ENC	= 0x4,
    HT_ACCEPT_LAN	= 0x8,
    HT_FROM		= 0x10,
    HT_IMS		= 0x20,
    HT_ORIG_URI		= 0x40,
    HT_REFERER		= 0x80,
    HT_USER_AGENT	= 0x200
} HTRqHd;

#define DEFAULT_REQUEST_HEADERS \
HT_ACCEPT_TYPE+HT_ACCEPT_CHAR+HT_ACCEPT_ENC+HT_ACCEPT_LAN+HT_REFERER+HT_USER_AGENT

extern void HTRequest_setRqHd (HTRequest *request, HTRqHd rqhd);
extern void HTRequest_addRqHd (HTRequest *request, HTRqHd rqhd);
extern HTRqHd HTRequest_rqHd (HTRequest *request);
</PRE>

<H3><A NAME="enhd">Entity Header Mask</A></H3>

The entity headers contain information about the object sent in the
HTTP transaction. See the <A HREF="../../Implementation/HTAnchor.html">Anchor module</A>,
for the storage of entity headers. This flag defines which headers are
to be sent in a request together with an entity body. All headers are
optional but the default value is <EM>ALL ENTITY HEADERS IF
PRESENT</EM>

<PRE>
typedef enum _HTEnHd {
    HT_ALLOW		= 0x1,
    HT_CONTENT_ENCODING	= 0x2,
    HT_CONTENT_LANGUAGE	= 0x4,
    HT_CONTENT_LENGTH	= 0x8,
    HT_CTE		= 0x10,			/* Content-Transfer-Encoding */
    HT_CONTENT_TYPE	= 0x20,
    HT_DERIVED_FROM	= 0x40,
    HT_EXPIRES		= 0x80,
    HT_LAST_MODIFIED	= 0x200,
    HT_LINK		= 0x400,
    HT_TITLE		= 0x800,
    HT_URI		= 0x1000,
    HT_VERSION		= 0x2000
} HTEnHd;

#define DEFAULT_ENTITY_HEADERS		0xFFFF			      /* all */

extern void HTRequest_setEnHd (HTRequest *request, HTEnHd enhd);
extern void HTRequest_addEnHd (HTRequest *request, HTEnHd enhd);
extern HTEnHd HTRequest_enHd (HTRequest *request);
</PRE>

<H3>Referer Field</H3>

If this parameter is set then a `Referer: &lt;parent address&gt; can
be generated in the request to the server, see <A
HREF="../../../Protocols/"> HTTP Protocol</A>

<PRE>
extern void HTRequest_setParent (HTRequest *request, HTParentAnchor *parent);
extern HTParentAnchor * HTRequest_parent (HTRequest *request);
</PRE>

<H3>Extra Headers</H3>

Extra header information can be send along with a request using this
variable. The text is sent as is so it must be preformatted with
&lt;CRLF&gt; line terminators. This will get changed at some point so
that you can register a header together with a handler in the MIME
parser.

<PRE>
extern void HTRequest_setExtra (HTRequest *request, char *extra);
extern char *HTRequest_extra (HTRequest *request);
</PRE>

<H2>Streams From Network to Application</H2>

<H3>Default Output Stream</H3>

The output stream is to be used to put data down to as they come in
<B>from</B> the network and back to the application. The default value
is <CODE>NULL</CODE> which means that the stream goes to the user
(display).

<PRE>
extern void HTRequest_setOutputStream (HTRequest *request, HTStream *output);
extern HTStream *HTRequest_OutputStream (HTRequest *request);
</PRE>

The desired format of the output stream. This can be used to get
unconverted data etc. from the library. If <CODE>NULL</CODE>, then <A
HREF="../../Implementation/HTFormat.html#FormatTypes">WWW_PRESENT</A> is default value.

<PRE>
extern void HTRequest_setOutputFormat (HTRequest *request, HTFormat format);
extern HTFormat HTRequest_OutputFormat (HTRequest *request);
</PRE>

<H3>Debug Stream</H3>

All object bodies sent from the server with status codes different
from <CODE>200 OK</CODE> will be put down this stream. This can be
used for redirecting body information in status codes different from
"200 OK" to for example a debug window. If the value is NULL (default)
then the stream is not set up.

<PRE>
extern void HTRequest_setDebugStream (HTRequest *request, HTStream *debug);
extern HTStream *HTRequest_DebugStream (HTRequest *request);
</PRE>

The desired format of the error stream. This can be used to get
unconverted data etc. from the library. The default value if
<CODE>WWW_HTML</CODE> as a character based only has one WWW_PRESENT.

<PRE>
extern void HTRequest_setDebugFormat (HTRequest *request, HTFormat format);
extern HTFormat HTRequest_DebugFormat (HTRequest *request);
</PRE>

<H2><A NAME="context">Context Swapping</A></H2>

In multi threaded applications it is often required to keep track of
the context of a request so that when the Library returns a result of
a request, it can be put into the context it was in before the request
was first passed to the Library. This call back function allows the
application to do this.

<PRE>
typedef int HTRequestCallback (HTRequest * request, void *param);

extern void HTRequest_setCallback (HTRequest *request, HTRequestCallback *cb);
extern HTRequestCallback *HTRequest_callback (HTRequest *request);
</PRE>

The callback function can be passed an arbitrary pointer (the void
part) which can describe the context of the current request
structure. If such context information is required then it can be set
using the following methods:

<PRE>
extern void HTRequest_setContext (HTRequest *request, void *context);
extern void *HTRequest_context (HTRequest *request);
</PRE>

<H2>Preemtive or Non-preemtive Access</H2>

A access scheme is defined with a default for using either preemtive
(blocking I/O) or non-premitve (non-blocking I/O). This is basically a
result of the implementation of the protocol module itself. However,
if non-blocking I/O is the default then some times it is nice to be
able to set the mode to blocking instead. For example when loading the
first document (the home page) then blocking can be used instead of
non-blocking.

<PRE>
extern void HTRequest_setPreemtive (HTRequest *request, BOOL mode);
extern BOOL HTRequest_preemtive (HTRequest *request);
</PRE>

<H2>Format Negotiation</H2>

When accessing the local file system, the Library is capable of
performing content negotioation as described by the HTTP
protocol. This is mainly for server applications, but some client
applications might also want to use content negotiation when accessing
the local file system. This method enables or disables content
negotiation - the default value is <EM>ON</EM>.

<PRE>
extern void HTRequest_setNegotiation (HTRequest *request, BOOL mode);
extern BOOL HTRequest_negotiation (HTRequest *request);
</PRE>

<H2>Error Manager Information</H2>

The error manager keeps a list (called an error stack) of all errors
and warnings occured during a request. The list of errors can be
accessed for generating an error message by the following function.

<PRE>
extern HTList *HTRequest_errorStack (HTRequest *request);
</PRE>

<H2>Bytes Read in Current Request</H2>

This function returns the bytes read in the current request. For a
deeper description of what the current request is, please read the
user's guide. This function can be used in for example the <A
HREF="../../Implementation/HTAlert.html">HTAlert module</A> to give the number of bytes
read in a progress message.

<PRE>
extern long HTRequest_bytesRead(HTRequest * request);
</PRE>


<H1>Managing the HyperDoc Object</H1>

<B>MORE</B>

<H1>The Access Manager</H1>

At this point most of the design issues have been addressed and the
Library it is now possible to use the Library to exchange information
between the application an the Internet. The Library provides a set of
functions that can be used to request a URI either on a remote server or
on the local file system. The access method binds the URL with a
specific protocol module as described in section
<A HREF="#access">Access Methods</A> and the stream chains defines the
data flow for incoming and outgoing data.</P>


<H2>Searching a URL</H2>

<B>MORE</B>

<H2>Receiving an Entity</H2>

<B>MORE</B>

<H2>Sending an Entity</H2>

<B>MORE</B>

<H2>Return Codes from the Access manager</H2>

The access manager has a standard set of return codes that the
application can use for diagnostics. They should only be used as
indications of the result as a more detailed description of any error
situation is registered  in the error handler. The set of codes are:</P>

<DL>

<DT><CODE>HT_LOADED</CODE>
<DD>A generic success code that indicates that the request has been
fulfilled

<DT><CODE>HT_NO_DATA</CODE>

<DD>Partly a success code, but no document has been retrieved and a
client application is encouraged to maintain the previous document view
as the current view. A <CODE>HT_NO_DATA</CODE> code might be the result
when a  telnet session is started etc.

<DT><CODE>HT_ERROR</CODE>

<DD>An error has occured and the request could not be fulfilled

<DT><CODE>HT_RETRY</CODE>

<DD>The remote server is temporarily unavailable and no more requests
should be issued to the server before the calendar time indicated in
<CODE>HTRequest-&gt;retry_after</CODE> field. No action is taken by the
Library to automatically retry the request, this is uniquely for the
application to decide. 

<DT><CODE>HT_WOULD_BLOCK</CODE>
<DD>An I/O operation would block and the request must pause. As the
request is not yet terminated, the operation will continue at a later
time when the blocking situation has ceased to exist.

</DL>

<H2>Context Swapping</H2>

In a multithreaded environment it is necessary to keep track of the
context of each simultanous requests issued to the Library as the
response might return in another order than the one they were
issued. The Library allows such a context registration in the <A
HREF="../../Implementation/HTAccess.html#z1">HTRequest structure</A>
by providing the registration mechanism of a call back function and a
pointer to an arbitrary data structure to be passed to that call back
function. <P>


<H1>The Protocol Manager</H1>

<B>MORE</B>


<H1>The Format Manager</H1>

<UL>
<LI>setting up request streams
<LI>memory management
<LI>examples
</UL>


<H1>The Cache Manager</H2>

Caching is a required part of any efficient Internet access
applications as it saves bandwidth and improves access performance
significantly in almost all types of accesses.  The Library supports
two different types of cache: The memory cache and the file cache. The
two types differ in several ways which reflects their two main
purposes: The memory cache is for short term storage of graphic
objects whereas the file cache is for intermediate term storage of
data objects. Often it is desirable to have both a memory and a file
version of a cached document, so the two types do not exclude each
other. The following paragraphs explains how the two caches can be
maintained in the Library.</P>

<H3><A NAME="memcache">Memory Cache</A></H3>

The memory cache is largely managed by the application as it simply
consists of keeping the graphic objects described by the
<CODE>HyperDoc</CODE> structure in memory as the user keeps requesting
new documents. The <CODE>HyperDoc</CODE> structure is only declared in
the Library - the real definition is left to the application as it is
for the application to handle graphic objects. The Line Mode Browser
has its own definition of the <CODE>HyperDoc</CODE> structure called
<A HREF="../../../LineMode/Implementation/GridText.html"
><CODE>HText</CODE></A>. Before a request is processed over the net,
the anchor object is searched for a <CODE>HyperDoc</CODE> structure
and a new request is issued only if this is not present or the Library
explicitly has been asked to reload the document, which is described
in the section <A HREF="#reload">Short Circuiting the Cache</A></P>

As the management of the graphic object is handled by the application,
it is also for the application to handle the garbage collection of the
memory cache. The <A HREF="../../../LineMode/">Line Mode Browser</A>
has a very simple memory management of how long graphic objects stay
around in memory. It is determined by a constant in the <A
HREF="../../../LineMode/Implementation/GridText.c" >GridText</A>
module and is by default set to 5 documents. This approach can be much
more advanced and the memory garbage collection can be determined by
the size of the graphic objects, when they expire etc., but the API is
the same no matter how the garbage collector is implemented. </P>


<H3>File Cache</H3>

The file cache is intended for intermediate term storage of documents
or data objects that can not be represented by the
<CODE>HyperDoc</CODE> structure which is referenced by the
<CODE>HTAnchor</CODE> object. As the definition of the
<CODE>HyperDoc</CODE> structure is done by the application there is no
explicit rule of what graphic objects that can not be described by the
<CODE>HyperDoc</CODE>, but often it is binary objects, like images
etc.</P>

The file cache in the Library is a very simple implementation in the
sense that no intelligent garbage collection has been defined. It has
been the goal to collect experience from the file cache in the W3C
proxy server before an intelligent garbage collector is implemented in
the Library.  Currently the following functions can be used to control
the cache, which is disabled by default:</P>

<DL>
<DT><CODE>HTCache_enable()</CODE>, <CODE>HTCache_disable()</CODE>, and
<CODE>HTCache_isEnabled()</CODE>
<DD>Use these functions to enable and disable the cache

<DT><CODE>HTCache_setRoot()</CODE> and <CODE>HTCache_getRoot()</CODE>
<DD>Use these functions to set and get the value of the cache root
</DL>

An important difference between the memory cache and the file cache is
the format of the data. In the memory cache, the cached objects are
graphic objects ready to be displayed to the user. In the file cache
the data objects are stored along with their metainformation so that
important header information like Expires, Last-Modified, Language
etc.  is a part of the stored object.</P>

<H3><A NAME="reload">Mode for Cache Refresh</A></H3>

In situations where a cached document is known to be stale it is
desired to flush any existent version of a document in either the
memory cache or the file cache and perform a reload from the
authoritative server. This can for example be the case if an expires
header has been defined for the document when returned from the origin
server. Forcing a refresh from either the memory cache, the file
cache, or both can be done using the following function:

<PRE>
void HTRequest_setReload (HTRequest *request, HTReload mode);
HTReload HTRequest_reload (HTRequest *request);
</PRE>

where <CODE>HTReload</CODE> can be either of the values

<DL>
<DT>HT_ANY_VERSION
<DD>Use any version available, either from memory cache or from local
file cache

<DT>HT_MEM_REFRESH

<DD><EM>Non-authoritative</EM> update of any version stored in
memory. The new version can either come from the local file cache, a
proxy cache or the network. If the request falls through to the
network, the Library issues a conditional GET using a
<EM>If-Modified-Since</EM> header. There are two main purposes for
this mode:

<OL>
<LI>If the disk cache is private to exactly one application then a
version stored in the local disk cache does normally not differ in
time from a version in memory - they have been created at the same
time. However, in a shared cache environment, the two versions can
differ and this flag can be used to force an update to the latest
version in the file cache.
<LI>If the application wants to see the metainformation as received
from the network, then the object in the file cache provides this
information whereas the version in memory does not.
</OL>

<DT>HT_CACHE_REFRESH

<DD><EM>Authoritative</EM> update of any version stored in the local
file cache or a proxy cache. The Library issues a conditional GET
using a <EM>If-Modified-Since</EM> header and a <EM>Pragma:
no-cache</EM> to ensure that the response is authoritative.

<DT>HT_FORCE_RELOAD

<DD>Unconditinal reload from the network using the <EM>Pragma:
no-proxy</EM> directive in order to insure that the reload is passed
to any proxy server on the way to the origin server

</DL>

If the Library receives either an authoritative or non-authoritative
"304 Not Modified" response upon any of the requests above, it 

<H3>Handling Expired Documents</H3>

There are various ways of handling Expires header when met in a
history list. Either it can be ignored all together, the user can be
notified with a warning, or the document can be reloaded
automatically. The Libarry supports either way, as it should be up to
the user to decide. The default action is HT_EXPIRES_IGNORE, but other
modes are to notify the user that a document is stale without
reloading it, and to do an automatic relaod of the document. Th
functions to use are in this case:

<PRE>
void HTAccess_setExpiresMode (HTExpiresMode mode, char *  notify);
HTExpiresMode HTAccess_expiresMode ();
</PRE>

where <CODE>HTExpiresMode</CODE> can take any of the values:

<PRE>
    HT_EXPIRES_IGNORE
    HT_EXPIRES_NOTIFY
    HT_EXPIRES_AUTO
</PRE>

<H1>The Error Manager</H1>

<B>MORE</B>

<H1>The Event Manager</H1>

<B>MORE</B>


<H1>The Log Module</H1>

It is possible to log the result of a request to the Library whether
regardless of what type of application is using the Library. The
current implementation of the log manager is very simple but it is
straight forward to replace the implementation with a more
sofisticated one. The current log format is defined as follows:

<PRE>
	&lt;HOST&gt; &lt;DATE&gt; &lt;METHOD&gt; &lt;URI&gt; &lt;RESULT&gt; &lt;CONTENT LENGTH&gt;
</PRE>

where the date and time stamp can be either in local time or
GMT. Logging is turned off but the application can enable it at any
time. However, it is also for the application to disable the logging
in order to close any open file descriptors etc. The exact log API is
described in the <A HREF="../../Implementation/HTLog.html">Log
Manager</A>.

<H1>Keeping Track of History</H1>

The Library supports client applications in keeping track of which
locations the user has visited while browsing the Web. The internal
history list is implemented in the <A
HREF="../../Implementation/HTHist.html">HTHist module</A>. This module
is completely autonomous as it is not used by any other modules in the
Library so if it is not referred to in the application code then it
will not be linked into the linked application. This means that if the
application does not need recording of history then no action is
required at all.<P>

The purpose of the history module is to try not to impose any
particular history mechanism policy but instead to allow various
different history mechanisms. The basic features of the history module
are:

<UL>
<LI>The module can handle multiple history lists
<LI>The underlying data structure is a linear list structure
<LI>The module keeps a position pointer into this list
<LI>The application can refer to an element in the list by an index
</UL>

Some of the navigation steps supported by the module are "back",
"forward", and jump to a position in the list. The details of the
module is listed in the declaration part of the <A
HREF="../../Implementation/HTHist.html">HTHist module</A>.

<H1>The HTTP/MIME Parser</H1>

In version 3.1 of the Library, the HTTP header parser has been made
significantly more flexible and does support all HTTP headers included
in the <A HREF="../../../Protocols/" >HTTP/1.0 specification</A> as
defined by the latest draft plus allows management of unknown
headers. Together with the support for extra headers as described in
section <A HREF="#request">The Request Object </A> this allows
applications more easily to experiment with HTTP.  All metainformation
relevant to the actual communication between the client and the server
is stored in the request object whereas the metainformation describing
the entity body is stored in the anchor object. It is important to
note that this information can be used both when requesting a document
on a remote server and when describing an entity that is to be sent to
a remote server using a method like <CODE>PUT</CODE> or
<CODE>POST</CODE>. Some of the more special headers are: </P>

<DL>
<DT><CODE>Allow</CODE></DT>
<DD>Builds a list of allowed methods for this entity

<DT><CODE>ContentEncoding</CODE></DT>
<DD>

<DT><CODE>ContentLanguage</CODE></DT>
<DD>Builds a list of natural languages

<DT><CODE>ContentLength</CODE></DT>
<DD>This parameter is now passed

<DT><CODE>ContentType</CODE></DT>
<DD>The <CODE>ContentType</CODE> header now support the <CODE>charset</CODE>
parameter and the <CODE>level</CODE> parameter, however none of them
are used by the <A HREF="#HTML">HTML parser</A> 

<DT><CODE>Date</CODE>, <CODE>Expires</CODE>, <CODE>RetryAfter</CODE>,
 and <CODE>LastModified</CODE></DT>
<DD>All date and time headers are parsed understanding the following
formats: RFC 1123, RFC 850, ANSI C's asctime(), and delta time. The
latter is a non-negative integer indicating seconds after the message
was received.  Note, that it is <EM>always</EM> for the application to
issue a new request as a function of any of the date and time headers..

<DT><CODE>DerivedFrom, Version</CODE></DT>
<DD>For handling version control when managing collaborative works
using HTTP.

<DT>Unknown Headers</DT>
<DD>Unknown headers are put into a separate list which the application
can accesss. 
 
</DL>  

<H1>Presentation Modules</H1>

The HTML parser has three different levels of APIs in order to make
the implementation as flexible as possible.  Depending on which API is
used by the application, the output can be a stream, a structured stream
or a set of callback functions as indicated in the figure below:

<P><IMG SRC="../Guide/Interfaces.gif" ALT="HTMLParser"><P>

<DL>

<DT>SGML Stream Interface

<DD>This interface provides the most basic API consisting of the
output from a stream without any form for structure imposed on the
data. The internal <A HREF="../../Implementation/SGML.html">SGML
parser</A> parses the data sequence, identifies SGML markup tags, and
passes the information on the the <A
HREF="../../Implementation/HTML.html">HTML parser</A>. However, if the
application has its own SGML parser and HTML parser, the internal
parsers can be disabled by removing the internal HTML converter called
<CODE>HTMLPresent()</CODE> used to present a graphic object on the
screen from both the global and the local list of converters and
presenters.

<DT>HTML Structured Stream Interface

<DD>If the application has its own HTML parser that understands the
structured output from the internal SGML parser then the second API
can be used. The current HTML parser in the Library is very basic and
does not understand many of the new features in HTML 2 and 3.

<DT>HText Call Back Interface

<DD>The last API can be in case the application prefers to use the
internal HTML parser and only wants to provide a platform dependent
definition of the callback functions defined in the <A
HREF="../../Implementation/HText.html" >HText module</A>.  Now, the
parsing is all done internally in the Library and the application is
only called with segments of fully parsed HTML. The callback functions
are all defined as prototypes in the <A
HREF="../../Implementation/HText.html" >HText module</A> but the
client must provide the actual code that defines the presentation
method used for a specific HTML tag.

</DL>

Due to the limited functionality of the internal HTML parsing module,
many applications have chosen to implement their own HTML
parser. Therefore many regard the HTML parser module as being an
<EM>application specific module</EM> instead of a <EM>dynamic
module</EM>. This will be alleviated in the next version of the
Library, which hopefully will ease the use of the internal HTML
parser. The current parser can be overriding as described in section
<A HREF="#override">Application Specific Modules</A>.

<H1>Application Specific Modules</H1>

As explained in the section <A HREF="#start">Get Started</A>, the
<EM>application specific modules</EM> are often implemented to support
a simple interface as provided by the Line Mode Browser. However,
these and other modules can be overridden by more complex
applications, for example using a GUI window manager. A Library module
is overriding by redefining all external references (normally declared
in the include file) by new definitions in an application module. By
doing this the linker takes the new definition of the module instead
of the Library version and links it into the final executable file.
The declaration (the include file) stays the same, but the definition
has changed. The application module does not need to be called the
same as the Library module, only the external references.  External
references are both global variables and public functions visible to
other modules. As an example, the following module:</P>

<PRE>	/* Library.c */
	char GlobalFlag;
	int GlobalFunction(void)
	{
		/* Library Implementation */
	}
</PRE>

 with the declaration file:</P>

<PRE>	/* Library.h */
	extern char GlobalFlag;
	extern int GlobalFunction(void);
</PRE>

 can get a new definition module</P>

<PRE>	/* Application.c */
	char GlobalFlag;
	int GlobalFunction(void)
	{
		/* Application Implementation */
	}
</PRE>

which will then be linked into the executable program. The
following paragraphs describe the </P>


<H3><A NAME="history">Keeping
Track of History</A></H3>

The Library has a simple method to keep
track of which locations the user has visited while browsing the Web.
The internal history list is implemented in the <A HREF="../../Implementation/HTHist.html"
>HTHist module</A>, and is based on a linear list of visited documents
with a destructive backtrack. The <A HREF="../../Implementation/HTHist.html"
>HTHist module</A> is completely autonomous as it is not used by any
other modules in the Library so if it is not referred to in the
application code then it will not be linked into the linked application.
This means that if the application does not need recording of history
then no action is required at all. </P>


<H3><A NAME="alert">User
Prompts and Confirmations</A></H3>

The <A HREF="../../Implementation/HTAlert.html"
>HTAlert module</A> contains the functionality for prompting the user
for confirmations, questions, input etc. and to pass information like
warnings, error etc. back to the user. The internal definition is based
on highly portable code using ANSI C functions for input and output so
it is required to override this module when implementing a GUI client.
The functions are divided into two groups:</P>

<UL>
<LI>A user interactive part requiring an action (confirmation etc) by
the user.
<LI>A part for sending messages to the user requiring no explicit
confirmation
</UL>

The main difference from the history module is that this module
is always linked into the application as it is used by other modules in
the Library. Hence the definition of the module must be provided either
by the internal or an external definition. The internal implementation
uses the global variable <EM>HTInteractive</EM> to define whether any
interaction should be directed to the user or not. If no interaction is
desired, like for example when running an application in batch mode,
then this flag prevents the application to prompt the user for any
confirmations. </P>


<H3>The External event loop</H3>

In case the
application has its own event loop, and wants to use the Library in <B>Passive
mode</B> then the internal <A HREF="../../Implementation/HTEvntrg.html">HTEvent
module</A> must be replaced by a new definition in the application.
</P>

<PRE>	<B>	MORE</B></PRE>

<H3>The Binding Module</H3>

As
mentioned in the section <A HREF="#bind">Bindings to the local file
system</A> the bindings between a data object and its content types,
languages etc. is by default done using file suffixes. However, this can
be replaces by, for example a database interface by overriding the <A HREF="../../Implementation/HTBind.html"
>HTBind module</A>.</P>

<H1>Global Flags</H1>

The global flags consist of global variables, environment variables,
and preprocessor defines. Some have already been introduced in the
previous sections but this section gives a more complete listing.

<H3>Global Variables</H3>

Global variables have until recently been in widespread use throughout
the Library but as this often conflicts with a multithreaded
environment, many global variables have been replaced with thread-safe
representations. However, many modules do still contain state
independent global variables defining display options, global
time-outs, trace options etc. Typical examples are the module to
generate <A HREF="../../Implementation/HTDir.html">directory
listings</A> for HTTP, FTP, and local file access to directories and
the <A HREF="../../Implementation/HTError.html" >error handling
module</A>.

Only four specific global variables are to be mentioned in this paper,
The first two must be defined in the application before linking with
the library, and they <EM>must</EM> be assigned values with specific
semantics.

<DL>

<DT><CODE>HTAppName</CODE>

<DD>A string defining the name of the application. This value is used
in the <EM>User-Agent</EM> field in the <A
HREF="../../../Protocols/">HTTP Protocol</A> and it must obey the
semantics for this field.

<DT><CODE>HTAppVersion</CODE>

<DD>A string defining the version of the application. The value is also
used in the <CODE>User-Agent</CODE> field and must obey the general
semantics for this field. 

<DT><CODE>HTSecure</CODE>
<DD>If this flag is enabled then the application has no access to the
local file system.  This allows applications to be used as a shell for
remote logins, for example using telnet. the default value is <EM>OFF</EM>

<DT><CODE>HTImProxy</CODE>
<DD>A proxy server must have a socket as the default destination for
incoming data in order to forward data either to the proxy client or to
the remote server. If this flag is set, then  the default behavior of
sending data to the user is diabled. The default value is <EM>OFF</EM>.

</DL>

<H3>Environment Variables</H3>

Apart from the environment
variables for setting up a proxy server or a gateway described in
section <A HREF="Methods.html">Access Methods</A>, the Library supports only
two other environment variables:
</P>

<DL>
<DT><CODE>WWW_HOME</CODE>
<DD>This variable is used by the help function
<CODE>HTHomeAnchor()</CODE> to find the address of the default document
to load when a client application is started. If no <CODE>WWW_HOME</CODE>
variable has been specified at run time, by default, the Library returns
<B>http://www.w3.org/</B>.
 
<DT><CODE>USERNAME</CODE>, <CODE>LOGNAME</CODE>, <CODE>USER</CODE>
<DD>These are the variables that are searched when looking for the user
name of the current user. They are somewhat platform dependent as the
<CODE>USERNAME</CODE> is for Windows NT, and the others are for Unix
with <CODE>LOGNAME</CODE> as having highest priority.

</DL>

<H3>Preprocessor Defines</H3>

Most of the preprocessor defines
in the Library are platform dependent that are determined as a result of
the <EM>BUILD script</EM>. However, there are some few defines that on
a platform independent basis can change the default behavior of the
Library.</P>

<DL>
<DT><CODE>HT_REENTRANT</CODE>

<DD>This boolean define should be enabled if the reentrant versions
("*_r") of the system calls should be used. The name of these system
calls are currently "*_r", for example <CODE>strtok_r</CODE>. The
default value is <EM>OFF</EM>.

<DT><CODE>HT_SHARED_DISK_CACHE</CODE>

<DD>If the cache can be shared between several clients this will have
an effect on the way, update of a document will be done. The default
cache implementation of the cache manager does not support this so the
default value is NOT defined.

<DT><CODE>HT_DIRECT_WAIS</CODE>

<DD>This boolean define is enabled by the <EM>Makefile.include</EM>
file as described in section <A HREF="Methods.html">Access Methods</A>. The
default value is <EM>OFF</EM>.

<DT><CODE>HT_DEFAULT_WAIS_GATEWAY</CODE>

<DD>A constant string value which WAIS gateway to contact if
<CODE>HT_DIRECT_WAIS</CODE> is not defined and no gateway has been
defined using environment variables

<DT><CODE>HT_FTP_NO_PORT</CODE>

<DD>The FTP module can handle both <CODE>PASV</CODE> and
<CODE>PORT</CODE> when requesting a document from a FTP server. If the
application is a proxy server running on top of a firewall machine
then <CODE>PORT</CODE> is normally not allowed as a firewall does not
accept incoming connections on arbitrary ports. This define will
disable the use of <CODE>PORT</CODE>. The default value is to
<EM>use</EM> <CODE>PORT</CODE> if <CODE>PASV</CODE> fails.

<DT><CODE>HT_NO_INIT</CODE>

<DD>If this flag is defined then the Library will not initialize any
access methods or media types in the <CODE>HTLibInit()</CODE>
function, but leaves this to the application. By default, the flag is
<EM>not</EM> defined.

<DT><CODE>WWWLIB_SIG</CODE>

<DD>The Library has a very small set of signal handlers whose action
most often are simply to ignore the signals. However, due to a bug in
the TCP kernel on Solaris and other SVR4 platforms returning a
SIG_PIPE signal, some kind of handling is required on these platforms,
and the signal handling is enabled by default on these platforms.

<DT><CODE>HT_TMP_ROOT</CODE>

<DD>The default destination for temporary files if no other
destination has been given by the application. Temporary files include
files created for external presenters etc. The default value is
<CODE>/tmp</CODE> which obviously is not suited for large amount of
data.

<DT><CODE>HT_CACHE_ROOT</CODE>

<DD>If the cache is enabled and no cache root directory has been
specified then use this as the location. The default value is again
<CODE>/tmp</CODE>.

<DT><CODE>HT_NO_RULES</CODE>

<DD>If this flag is enabled then no configuration or rule file is
searched for map rules when handling a request even if a rule file has
been specified by the application. The default value is <EM>OFF</EM>

<DT><CODE>HT_NO_PROXY</CODE>

<DD>If no environment variables are to be searched for gateways or
proxies for a request. The default value is <EM>OFF</EM>

</DL>

<P>
<HR>
<ADDRESS>Henrik Frystyk, <A HREF="mailto:libwww@w3.org">libwww@w3.org</A>, July 1995</ADDRESS>
</BODY>
</HTML> 
